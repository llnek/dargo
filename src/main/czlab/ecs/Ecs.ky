;; Copyright (c) 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.elmo.ecs.Ecs

  (:require ["kirby"
             :as K
             :refer [nichts? some? opt?? conj! MAX-INT]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype EntityPool []

  (constructor [entity batch]
    (assign! this
             :size 0 :marker 0
             :objs []
             :entity entity :batch batch))

  (take [&args]
    (if (>= this.marker
            this.poolSize) (.expandPool this))
    (var obj (nth this.objs this.marker))
    (assign! obj :index this.marker)
    (assign! this :marker (++ this.marker))
    (obj.constructor.apply obj args) obj)

  (expandPool []
    (dotimes [x this.batch]
      (conj! this.objs (new this.entity)))
    (assign! this :size (+ this.batch this.size)))

  (yield [ent]
    (assign! this :marker (-- marker))
    (var end (nth this.objs this.marker)
         endIndex (get end :index))
    (set-in! this.objs this.marker ent)
    (set-in! this.objs ent.index end)
    (assign! end :index ent.index)
    (assign! ent :index endIndex)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype EntityPool []

  (constructor [name ctor batch]
    (assign! this :name name :objs [] :ctor ctor :batch batch))

  (preset []
    (dotimes [n this.batch]
      (if-some [r (this.ctor)]
        (conj! this.objs r))) nil)

  (get []
    (or (.find this #(get % :poolable?))
        (do (.preset this) (.get this))))

  (take [] (when-some [r (.get this)]
             (assign! r :poolable? #f) r))

  (getAt [pos] (nth this.objs pos))
  (foreach [f] (each f this.objs))
  (find [cb] (find cb this.objs))
  (some [f] (some f this.objs))

  (size [] (n# this.objs))

  (clearAll [] (do->nil (.reset this)
                        (K/resetVec! this.objs)))

  (actives []
    (filter #(not (get % :poolable?)) this.objs))

  (reset []
    (do->nil (each #(assign! % :poolable? #t) this.objs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Component []
  (constructor [&[e]]
    (assign! this
             :tpid ""
             :entity (opt?? e nil))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const SystemPriority {
  :PreUpdate 100
  :NetPlay 200
  :AI 300
  :Motion 400
  :Move 500
  :Logic 600
  :Collide 700
  :Resolve 800
  :Render 900
  :Error -1 })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;engine
(def- lastId 0)
(defn- generateEid "" [pfx]
  (var rc (++ lastId))
  (if-not (< rc MAX-INT) (raise! "too many entities")) (str pfx rc))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Engine []

  (constructor [&[cfg]]
    (assign! this
             :config (opt?? cfg nil)
             :updating? #f
             :pools []
             :systems [] :ents {} :types {}))

  (unbind [co ent]
    (var cid (if (inst? Component co) co.tpid co))
    (when-some [m (get this.types cid)] (dissoc! m ent.eid)) nil)

  (bind [co ent]
    (var m (get this.types co.tpid))
    (when (nichts? m)
      (set! m {})
      (assoc! this.types co.tpid m))
    (assoc! m ent.eid co) nil)

  (find [comType & comTypes]
    (var pmin MAX-INT
         missed? #f pm nil ccs [] ret [])
    (.unshift comTypes comType)
    ;;find shortest cache, doing an intersection
    (var~ pmks ccsz eid cid c sum)
    (for [i 0 sz (n# comTypes)
          :while (< i sz) :recur (+1 i)]
      (set! cid (.@i comTypes)
            c (get this.types cid))
      (cond
        (nichts? c) (do->break! (true! missed?))
        :else
        (do (when (< (n# c) pmin)
              (set! pmin (n# c) pm c))
            (conj! ccs c))))
    ;;use the shortest cache as the baseline
    (set! ccsz (n# ccs))
    (when (and (> ccsz 0)
               (not missed?))
      (set! pmks (keys pm))
      (for [i 0 sz (n# pmks)
            :while (< i sz) :recur (+1 i)]
        (set! sum 0
              eid (.@i pmks))
        ;; look for intersection
        (for [j 0 :while (< j ccsz) :recur (+1 j)]
          (set! c (.@j ccs))
          (if (= c pm)
            (++ sum)
            (if (get c eid) (++ sum))))
        ;; if found in all caches...
        (if (= sum ccsz) ;; all matched
          (if-some [e (get this.ents eid)] (conj! ret e))))) ret)

  (addSystem [s]
    (conj! this.systems s)
    (sort System.compare this.systems) s)

  (removeSystem [s]
    (var p (.indexOf this.systems s))
    (when-not (neg? p)
      (.splice this.systems p 1)
      (sort System.compare this.systems)) nil)

  (deleteSystems []
    (K/resetVec! this.systems) nil)

  (getSystem [s]
    (find #(== s (get % :sid)) this.systems))

  (update [time]
    (assign! this :updating? #t)
    (var stop? #f)
    (each (fn [s]
            (when (and (not stop?)
                       (get s :active?))
              (if-not (.update s time) (true! stop?)))) this.systems)
    (assign! this :updating? #f) nil)

  (ignite [prologue]
    (prologue)
    (each #(.preamble %) this.systems) nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Entity []

  (constructor [engine &[name]]
    (assign! this
             :poolable? #t
             :status #t
             :name (opt?? name "")
             :comps {}
             :engine engine
             :eid (generateEid "ent:")))

  (checkin [co]
    (assert (not (.has? this co.tpid)) "Cannot add co twice")
    (.bind this.engine co this)
    (assign! co :entity this)
    (assoc! this.comps co.tpid co) co)

  (checkout [comType]
    (when-some [co (get this.comps comType)]
      (dissoc! this.comps comType)
      (.unbind this.engine co this) co))

  (get [comType] (get this.comps comType))
  (getAll [] (values this.comps))
  (has? [comType] (some? (get this.comps comType))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype System []

  (update [time] (.evalFunc this time))

  (compare ^:static [x y]
    (if (< x.priority y.priority) -1
      (if (> x.priority y.priority) 1 0)))

  (constructor [priority engine func]
    (assign! this
             :active? #t
             :evalFunc func
             :engine engine
             :priority priority)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF

