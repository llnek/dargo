(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.elmo.core.ecs

  (:require ["kirby"
             :as ky :refer []]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Component []
  ""
  (constructor [&[n]] (assign! this :node (opt?? n null))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const PreUpdate 100)
(const NetPlay 200)
(const AI 300)
(const Motion 400)
(const Move 500)
(const Logic 600)
(const Collide 700)
(const Resolve 800)
(const Render 900)
(const Error -1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;engine
(def- lastId 0)
(defn- generateEid "" []
  (var rc (++ lastId))
  (if-not (< rc Number/MAX_SAFE_INTEGER)
    (raise! "too many entities"))
  rc)

(deftype Engine []
  ""
  (constructor [&[cfg]]
    (assign! this
            :config (opt?? cfg nil)
            :updating? #f
            :systems []
            :ents {}
            :types {}
            :garbo []))

  (unbind [co e] (.unbind this (get co :tpid) e))

  (unbind [cid e]
    (when-some [m (get this.types cid)]
      (dissoc! m (.eid e)))
    nil)

  (bind [co e]
    (var cid (get co :tpid)
         eid (get e :eid)
         m (get this.types cid))
    (when (nichtcs? m)
      (assoc! this.types cid m)
      (set! m (get this.types cid)))
    (assoc! m eid co)
    nil)

  (findNodes
    "Find all nodes having these components"
    [comType & comTypes]
    (var pmin Number/MAX_SAFE_INTEGER
         missed? #f pm nil ccs [] ret [])
    (.unshift comTypes comType)
    ;;find shortest cache, doing an intersection
    (var~ pmks ccsz eid cid c sum)
    (for [i 0 sz (n# comTypes)
          :while (< i sz) :recur (+1 i)]
      (set! cid (.@i comTypes)
            c (get this.types cid))
      (cond
        (nichts? c) (do->break! (true! missed?))
        :else
        (do (when (< (n# c) pmin)
              (set! pmin (n# c) pm c))
            (conj! ccs c))))
    ;;use the shortest cache as the baseline
    (set! ccsz (n# ccs))
    (when (and (> ccsz 0)
               (not missed?))
      (set! pmks (keys pm))
      (for [i 0 sz (n# pmks)
            :while (< i sz) :recur (+1 i)]
        (set! sum 0
              eid (.@i pmks))
        ;; look for intersection
        (for [j 0 :while (< j ccsz) :recur (+1 j)]
          (set! c (.@j ccs))
          (if (= c pm)
            (++ sum)
            (if (get c eid) (++ sum))))
        ;; if found in all caches...
        (if (= sum ccsz) ;; all matched
          (if-some [e (get this.ents eid)]
            (conj! ret e)))))
    ret)

  (getNodes "" [] (values this.ents))

  (createNode "" [n take?]
    (var eid (generateEid)
         e (new Node this n eid))
    (assoc! this.ents eid e)
    (if take? (.take! e))
    e)

  (deleteNode "" [e]
    (asset (.ok? e) "Cannot delete twice!")
    (.die! e)
    (conj! this.garbo e)
    (dissoc! this.ents (.eid e))
    nil)

  (deleteNodes "" []
    (std/resetMap! this.ents)
    (doHouseKeeping)
    nil)

  (addSystem "" [s]
    (conj! this.systems s)
    (sort this.systems)
    s)

  (deleteSystem "" [s]
    (var p (.indexOf this.systems s))
    (when-not (neg? p)
      (.splice this.systems p 1)
      (sort this.systems))
    nil)

  (deleteSystems "" []
    (std/resetVec! this.systems) nil)

  (update "" [time]
    (assign! this :updating #t)
    (var stop? #f)
    (doseq [s this.systems
            :when (.active? s)
            :while (not stop?)]
      (if-not (.update s time) (true! stop?)))
    (doHouseKeeping)
    (assign! this :updating #t)
    nil)

  (ignite "" [initNodes initSystems]
    (initNodes)
    (initSystems)
    (doseq [s this.systems] (.preamble s)) nil)

  (doHouseKeeping "" [] ))

;;;;;;;;;;;;;;;;;
; nodes
(deftype Node [ecs/Poolable]

  (constructor "" [e n id]
    (assoc! this
            :status #t
            :cobjs {}
            :engine e
            :dead? #f
            :name n
            :node-id id))

  (die! "" [] (assoc! this :dead? #t))
  (eid "" [] (get this :node-id))
  (ok? "" [] (get this :status))

  (checkin "" [c]
    (var cid (get c :tpid))
    (assert (not (.has this cid)) "Cannot add twice")
    (.bind this.engine c this)
    (.setNode c this)
    (assoc! this.cobjs cid c)
    nil)

  (delete "" [comType]
    (when-some [c (get this.cobjs comType)]
      (dissoc! this.cobjs comType)
      (.unbind this.engine c this))
    nil)

  (get "" [comType]
    (get this.cobjs comType))

  (getAll "" [] (values this.cobjs))

  (has? "" [comType]
    (get this.cobjs comType)))

;;;;;;;;;;;;;;;;
; systems

#define __decl_sys_tpid(x) \
  virtual const ecs::SystemType typeId() { return x; }

#define __decl_sys_priority(x) \
  virtual int priority() { return x; }

#define __decl_sys_preamble() \
  virtual void preamble();

#define __decl_sys_update() \
  virtual bool update(float);

;;;;;;;;;;;;;;;
(deftype System []

  (active? [] (get this :active?))
  (getEngine [] this.engine)
  (isa [t] (== (get this :tpid) t))

  (suspend [] (assoc! this :active? #f))
  (restart [] (assoc! this :active? #t))

  (constructor [e] (assoc! this
                          :active? #t
                          :engine e)))










