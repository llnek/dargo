
(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.elmo.core.ecs

  (:require ["kirby"
             :as ky :refer []]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Poolable []
  (constructor [] (.yield! this))
  (take! [] (assign! this :status #t))
  (yield! [] (assign! this :status #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype FPool []
  (constructor [ctor batch]
    (assign! this :objs [] :ctor ctor :batch batch))
  (preset
    [f cnt]
    (dotimes [n cnt]
      (if-some [r (f)]
        (conj! this.objs r)))
    (assign! this :batch cnt :ctor f) nil)

  (take [] (when-some [r (.get this)] (.take! r) r))
  (find [cb] (find cb this.objs))
  (getAt [pos] (nth this.objs pos))
  (size [] (n# this.objs))
  (get []
    (var obj (.find this #(not (.-status %))))
    (when (and (nichts? obj)
               create?
               this.ctor)
      (.preset this this.ctor this.batch)
      (set! obj (.get this #f)))
    obj)

  (checkin [c]
    (if c (conj! this.objs c)) nil)

  (clearAll [] (std/resetVec! this.objs) nil)

  (actives []
    (filter #(.-status %) this.objs))

  (foreach [f]
    (each f this.objs))

  (some [f]
    (some f this.objs))

  (reset
    "Hibernate (status off) all objects in the pool" []
    (each #(.yield! %) this.objs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Component []
  ""
  (constructor [&[n]]
    (assign! this
             :tpid ""
             :node (opt?? n nil))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const PreUpdate 100)
(const NetPlay 200)
(const AI 300)
(const Motion 400)
(const Move 500)
(const Logic 600)
(const Collide 700)
(const Resolve 800)
(const Render 900)
(const Error -1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;engine
(def- lastId 0)
(defn- generateEid "" []
  (var rc (++ lastId))
  (if-not (< rc Number/MAX_SAFE_INTEGER)
    (raise! "too many entities"))
  rc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype Engine []
  ""
  (constructor [&[cfg]]
    (assign! this
             :config (opt?? cfg nil)
             :updating? #f
             :systems [] :nodes {} :types {}))

  (unbind [co node]
    (var cid (if (inst? Component co) co.tpid co))
    (when-some [m (get this.types cid)]
      (dissoc! m (.-eid node)))
    nil)

  (bind [co node]
    (var eid (.-eid node)
         cid (.-tpid co)
         m (get this.types cid))
    (when (nichts? m)
      (set! m {})
      (assoc! this.types cid m))
    (assoc! m eid co) nil)

  (findNodes
    "Find all nodes having these components"
    [comType & comTypes]
    (var pmin Number/MAX_SAFE_INTEGER
         missed? #f pm nil ccs [] ret [])
    (.unshift comTypes comType)
    ;;find shortest cache, doing an intersection
    (var~ pmks ccsz eid cid c sum)
    (for [i 0 sz (n# comTypes)
          :while (< i sz) :recur (+1 i)]
      (set! cid (.@i comTypes)
            c (get this.types cid))
      (cond
        (nichts? c) (do->break! (true! missed?))
        :else
        (do (when (< (n# c) pmin)
              (set! pmin (n# c) pm c))
            (conj! ccs c))))
    ;;use the shortest cache as the baseline
    (set! ccsz (n# ccs))
    (when (and (> ccsz 0)
               (not missed?))
      (set! pmks (keys pm))
      (for [i 0 sz (n# pmks)
            :while (< i sz) :recur (+1 i)]
        (set! sum 0
              eid (.@i pmks))
        ;; look for intersection
        (for [j 0 :while (< j ccsz) :recur (+1 j)]
          (set! c (.@j ccs))
          (if (= c pm)
            (++ sum)
            (if (get c eid) (++ sum))))
        ;; if found in all caches...
        (if (= sum ccsz) ;; all matched
          (if-some [e (get this.ents eid)]
            (conj! ret e)))))
    ret)

  (getNodes "" [] (values this.ents))

  (createNode "" [n take?]
    (var eid (generateEid)
         e (new Node this n eid))
    (assoc! this.ents eid e)
    (if take? (.take! e))
    e)

  (deleteNode "" [e]
    (asset (.ok? e) "Cannot delete twice!")
    (.die! e)
    (conj! this.garbo e)
    (dissoc! this.ents (.eid e))
    nil)

  (deleteNodes "" []
    (std/resetMap! this.ents)
    (doHouseKeeping)
    nil)

  (addSystem "" [s]
    (conj! this.systems s)
    (sort System.compare this.systems)
    s)

  (deleteSystem "" [s]
    (var p (.indexOf this.systems s))
    (when-not (neg? p)
      (.splice this.systems p 1)
      (sort System.compare this.systems))
    nil)

  (deleteSystems "" []
    (std/resetVec! this.systems) nil)

  (getSystem "" [s]
    (_1 (filter #(== s (get % :tpid)) this.systems)))

  (update "" [time]
    (assign! this :updating #t)
    (var stop? #f)
    (doseq [s this.systems
            :when (.active? s)
            :while (not stop?)]
      (if-not (.update s time) (true! stop?)))
    (doHouseKeeping)
    (assign! this :updating #t)
    nil)

  (ignite "" [initNodes initSystems]
    (initNodes)
    (initSystems)
    (doseq [s this.systems] (.preamble s)) nil)

  (doHouseKeeping "" [] ))

;;;;;;;;;;;;;;;;;
; nodes
(deftype Node [ecs/Poolable]

  (constructor "" [e n id]
    (assoc! this
            :status #t
            :cobjs {}
            :engine e
            :dead? #f
            :name n
            :node-id id))

  (die! "" [] (assoc! this :dead? #t))
  (eid "" [] (get this :node-id))
  (ok? "" [] (get this :status))

  (checkin "" [c]
    (var cid (get c :tpid))
    (assert (not (.has this cid)) "Cannot add twice")
    (.bind this.engine c this)
    (.setNode c this)
    (assoc! this.cobjs cid c)
    nil)

  (delete "" [comType]
    (when-some [c (get this.cobjs comType)]
      (dissoc! this.cobjs comType)
      (.unbind this.engine c this))
    nil)

  (get "" [comType]
    (get this.cobjs comType))

  (getAll "" [] (values this.cobjs))

  (has? "" [comType]
    (get this.cobjs comType)))

;;;;;;;;;;;;;;;;
; systems

;;;;;;;;;;;;;;;
(deftype System []
  ""
  (active? [] (get this :active?))
  (getEngine [] this.engine)
  (isa [t] (== (get this :tpid) t))

  (suspend [] (assign! this :active? #f))
  (restart [] (assign! this :active? #t))

  (compare ^:static [x y]
    (if (< x.priority y.priority) -1
      (if (> x.priority y.priority) 1 0)))

  (constructor [e] (assign! this
                            :priority 0
                            :active? #t
                            :engine e)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF









