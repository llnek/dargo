;; Copyright (c) 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.basal.core.EBus

  (:require ["kirby"
             :as K
             :refer [atom mapcat inc reset! swap!]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- _SEED (atom 0))
(defn- nextSEQ "" [] (swap! _SEED inc))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- re-space #/\s+/)
(def- re-slash #/\//)
(def- re-dot #/\./)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- splitTopic "" [topic sep]
  (if (string? topic)
    (->> (.split topic (if (== sep ".") re-dot re-slash))
         (filter #(not-empty %))) []))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype PubSub []
  "Event Pub-Sub interface"
  (sub* "One time only subscription" [topics listener] )
  (sub+ "Standard subscription" [topics listener] )
  (pub "Send a message" [topic msg] )
  (match? "Internal: test only" [topic] )
  (dbg "internal: test only" [] )
  (resume "Resume this subscriber" [handle] )
  (pause "Pause this subscriber" [handle] )
  (unsub "Remove this subscriber" [handle] )
  (addOneTopic "" [&xs] )
  (delOneTopic "" [&xs] )
  (addTopic "" [&xs] )
  (unSub "" [&xs] )
  (finz "Remove all" [] ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- mkSubSCR "" [topic listener options]
  {:pre [(fn? listener)]}
  (let [{:keys [subjectDelimiter repeat? bufsz]} options]
    (-> {:action listener}
        (merge
          {:subjDelim subjectDelimiter
           :id (str "s#" (nextSEQ))
           :repeat? repeat?
           :async? #f :topic topic :status [1]}))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; nodes - children
;; subscribers
(defn- mkLevelNode "" [] {:levels {} :subcs {}})
(defn- mkTreeNode "" [] {:topics {} :subcs {}})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- addOneSub "" [node sub]
  (update-in node [:subcs] assoc! (get sub :id) sub))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- remOneSub "" [node sub]
  (update-in node [:subcs] dissoc! (get sub :id) sub))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- interleavePath
  "" [paths] (mapcat #([:levels %]) paths))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- listen
  "For each topic, subscribe to it."
  [root kind topics listener options]
  (let [r
        (->> (-> (or topics "")
                 (.trim )
                 (.split re-space))
             (filter #(not-empty %))
             (map #(addTopic root
                             kind
                             (mkSubSCR % listener options))))]
    (if (= 1 (n# r)) (_1 r) r)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- run "" [subcs topic msg]
  (doseq [[_ z] subcs
          :let [{:keys [repeat? action status]} z]
          :when (pos? (_1 status))]
    (action (get z :topic) topic msg)
    (if-not repeat? (aset status 0 -1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- walk "" [branch pathTokens topic msg tst]
  (let [{:keys [levels subcs]} branch
        [p & more] pathTokens
        cur (get levels p)
        s1 (get levels "*")
        s1c (get s1 :levels)
        s2 (get levels "**")]
    (when s2
      (if tst
        (swap! tst inc)
        (run (get s2 :subcs) topic msg)))
    (if s1
      (cond
        (and (empty? more)
             (empty? s1c))
        (if tst
          (swap! tst inc)
          (run (get s1 :subcs) topic msg))
        (and (not-empty s1c)
             (not-empty more))
        (walk s1 more topic msg tst)))
    (when cur
      (if (not-empty more)
        (walk cur more topic msg tst)
        (if tst
          (swap! tst inc)
          (run (get cur :subcs) topic msg))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- resume "" [root hd]
  (var sub (get (get root :subcs) hd)
       st (if sub (get sub :status))
       sv (if st (_1 st) -1))
  (if (= 0 sv) (aset st 0 1)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- pause "" [root hd]
  (var sub (get (get root :subcs) hd)
       st (if sub (get sub :status))
       sv (if st (_1 st) -1))
  (if (pos? sv) (aset st 0 0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addOneRBusTopic "" [top kind {:keys [topic subjDelim] :as sub}]
  (let [path (interleavePath (splitTopic topic subjDelim))]
    (-> (update-in top path addOneSub sub)
        (update-in [:subcs] assoc! (get sub :id) sub))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addRBusTopic "" [root kind sub]
  (swap! root addOneRBusTopic kind sub) (get sub :id))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addOneEBusTopic "" [top kind {:keys [topic] :as sub}]
  (-> (update-in top
                 [:topics topic]
                 assoc! (get sub :id) sub)
      (update-in [:subcs] assoc! (get sub :id) sub)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addEBusTopic "" [root kind sub]
  (swap! root addOneEBusTopic kind sub) (get sub :id))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn delTopic "" [top kind {:keys [topic] :as sub}]
  (var id (get sub :id))
  (if (== :rv kind)
    (let [path (interleavePath (splitTopic topic))]
      (-> (update-in top path remOneSub sub)
          (update-in [:subcs] dissoc! id)))
    (-> (update-in top [:topics topic] dissoc! id)
        (update-in [:subcs] dissoc! id))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype EventBus []

  (constructor [kind options]
    (var s (if (== :rbus kind)
             (mkLevelNode) (mkTreeNode)))
    (assign! this
             :state (atom s)
             :kind kind
             :options (or options {})))

  (sub* [topics listener]
    (listen @@state
            @@kind
            topics
            listener
            (merge @@options
                   {:repeat? #f })))

  (sub+ [topics listener]
    (listen @@state
            @@kind
            topics
            listener
            (merge @@options
                   {:repeat? #t })))

  (pub [topic msg]
    (var s (deref @@state))
    (if (== :rbus @@kind)
      (if-some+ [tokens (splitTopic topic "/")]
                (walk s tokens topic msg nil))
      (if-some [sub (get-in s [:topics topic])]
               (run sub topic msg))))

  (resume [hd] (resume (deref @@state) hd))

  (pause [hd] (pause (deref @@state) hd))

  (unsub [hd]
    (var s (deref @@state))
    (if-some [x (get-in s [:subcs hd])]
      (swap! s delTopic kind x)) nil)

  (match? [topic]
    (var s (deref @@state))
    (if (== :rbus @@kind)
      (let [tokens (splitTopic topic)
            z (atom 0)]
        (if (not-empty tokens)
          (walk s tokens topic nil z))
        (pos? @z))
      (contains? (get s :topics) topic)))

  (dbg [] (K/prn (deref @@state)))

  (finz []
    (do->nil (reset! @@state
                     (if (== :rbus @@kind)
                       (mkLevelNode)
                       (mkTreeNode))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn eventBus
  "A Publish Subscribe event manager.  If subject based is
  used, a more advanced matching scheme will be used - such as
  wild-card matches."
  [&options]
  (var {:keys [subjectBased?]} (opt?? options {}))
  (new EventBus
       (if subjectBased? :rbus :ebus) options))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF


