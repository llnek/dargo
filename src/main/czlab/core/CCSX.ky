
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.elmo.core.CCSX
  (:require ["kirby"
             :as ky :refer []]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pop "" [] (.popScene cc/director))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn randomPos "" [node]
  (var wb (visBox))
  (.setPosition node
                (randInt wb.right)
                (randInt wb.top)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mkHMenu "" [items pad] (mkMenu items #f pad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mkVMenu "" [items pad] (mkMenu items #t pad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- mkMenu
  "menu-items should be same size"
  [items vert? pad]
  (var menu (cc/Menu.create))
  (each #(.addChild menu %) items)
  (if vert?
    (.alignItemsVerticallyWithPadding menu pad)
    (.alignItemsHorizontallyWithPadding menu pad))
  menu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn wrapMenu "" [item]
  (doto (cc/Menu.create)
    (.addChild item)
    (.setPosition 0 0)
    (.setAnchorPoint (anchorBL))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isDesktop "" [] (raise! "TBD"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn splitHexColor "" [rgbstr]
  (var f /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
       s /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/
       len (n# rgbstr)
       arr (or (.exec f color)
               (.exec s color)))
  (when arr
    (set! arr (slice arr 1))
    (map #(parseInt (str "0x" %))
         (if (= len 4) (map #(str % %) arr) arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn colorRGB "" [rgbstr]
  (var [r g b] (splitHexColor rgbstr)) (cc/color r g b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sfxMusic "" [music repeat?]
  (var url (xcfg/getMusic music))
  (try
    (.playMusic cc.audioEngine url repeat?)
    (catch e
      (cc.warn (cc/formatStr
                 "Failed to play music: %s" music)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sfxPlay "" [sound]
  (var url (xcfg/getEffect sound))
  (try
    (.playEffect cc.audioEngine url)
    (catch e
      (cc.warn (cc/formatStr
                 "Failed to play sound: %s" sound)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pauseEffects "" [] (.pauseAllEffects cc.audioEngine))
(defn pauseMusic "" [] (.pauseMusic cc.audioEngine))
(defn pauseAudio "" [] (pauseEffects) (pauseMusic))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resumeEffects "" [] (.resumeAllEffects cc.audioEngine))
(defn resumeMusic "" [] (.resumeMusic cc.audioEngine))
(defn resumeAudio "" [] (resumeEffects) (resumeMusic))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn stopEffects "" [] (.stopAllEffects cc.audioEngine))
(defn stopMusic "" [] (.stopMusic cc.audioEngine))
(defn stopAudio "" [] (stopEffects) (stopMusic))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn calcOffsets "" [sz]
  (cc/size (/ sz.width *golden-ratio*)
           (/ sz.height *golden-ratio*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reifySpriteBatch "" [name]
  (->> (xcfg/getImage name)
       (.addImage cc.textureCache)
       (cc/SpriteBatchNode.createWithTexture )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createAudioMItems "" [&[onIcon ovIcon]]
  (set! ovIcon (opt?? ovIcon "sound_off.png")
        onIcon (opt?? onIcon "sound_on.png"))
  [(createMenuBtn ovIcon ovIcon)
   (createMenuBtn onIcon onIcon)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createAudioMImages "" [&[onIcon ovIcon]]
  (set! ovIcon (opt?? ovIcon "sound_off.png")
        onIcon (opt?? onIcon "sound_on.png"))
  [(createMenuImg ovIcon ovIcon)
   (createMenuImg onIcon onIcon)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn calcDist "" [node-a node-b]
  (cc.pDistance (.getPosition node-a)
                (.getPosition node-b)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn normalize "" [node-a node-b]
  (cc/pNormalize (cc/pSub (.getPosition node-b)
                          (.getPosition node-a))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createMenuText "" [fnt point txt color]
  (var z (createTTFLabel fnt point txt))
  (.setColor z color)
  (cc/MenuItemLabel.create z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createMenuText "" [fnt txt color]
  (var z (createBMFLabel fnt txt))
  (.setColor z color)
  (cc/MenuItemLabel.create z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createMenuImg "" [normal & [selected]]
  (set! selected (opt?? selected normal))
  (cc/MenuItemSprite.create
    (createSprite normal) (createSpeite selected)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createMenuBtn "" [normal & [selected]]
  (set! selected (opt?? selected normal))
  (cc/MenuItemImage.create
    (xcfg/getImage normal) (xcfg/getImage selected)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pointInBox?
  "Test if this point is inside this rectangle"
  [box & [x y]]
  (when-not (number? x)
    ;x is a point and y is not set
    (set! y x.y x x.x))
  (and (>= x box.left)
       (<= x box.right)
       (>= y box.bottom) (<= y box.top)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createBMFLabel "" [fnt txt & [x y]]
  (var f (.createWithBMFont cc/Label
                            (xcfg/getFont fnt) txt))
  (.setOpacity f (* 0.9 255))
  (when (or (number? x)
            (some? x))
    (if-not (number? x)
      (set! y x.y x x.x))
    (.setPosition f x y))
  f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createTTFLabel "" [fnt sz txt & [x y]]
  (var f (.createWithTTF cc/Label
                         txt
                         (xcfg/getFont fnt) sz))
  (when (or (number? x)
            (some? x))
    (if-not (number? x)
      (set! y x.y x x.x))
    (.setPosition f x y))
  f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn collide?
  "Test collision of 2 sprites"
  [node-a node-b]
  (if (and node-a node-b)
    (.intersectsRect (bbox node-a)
                     (bbox node-b)) #f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setDevRes "" [x y policy]
  (-> (.getOpenGLView cc.director)
      (.setDesignResolutionSize x y policy)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isTapped? "" [node tap]
  (<= (.distance tap (.getPosition node))
      (* 0.8 (get-in (.getBoundingBox node)
                     [:size :width]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deltaX "" [node-a node-b]
  (- (.getPositionX node-a) (.getPositionX node-b)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deltaY "" [node-a node-b]
  (- (.getPositionY node-a) (.getPositionY node-b)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isPortrait? "" []
  (var s (screen)) (> s.height s.width))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn readPlist "" [url]
  (var s (.getStringFromFile jsb/fileUtils url))
  (.parse cc/plistParser s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn readJson "" [url]
  (var s (.getStringFromFile jsb/fileUtils url))
  (JSON/parse s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment
(defn outOfBound? "" [node B]
  (if node (outOfBound (bbox4 node) B) #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn outOfBound? "" [a B]
  (or (> a.left B.right)
      (< a.top B.bottom)
      (< a.right B.left)
      (> a.bottom B.top)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn scaleSize "" [z scale]
  (cc/size (* z.width scale) (* z.height scale)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn undoTimer "" [tm] (if tm (.release tm)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createTime
  "Reify a timer action"
  [par millis]
  (var t (.create cc/DelayTime (/ millis 1000.0)))
  (.retain t)
  (.runAction par t)
  t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn timerDone? "" [t] (if t (.isDone t) #f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createAnimation "" [dpu restore? loops]
  (doto (.create cc/Animation)
    (.setRestoreOriginalFrame restore?)
    (.setDelayPerUnit dpu)
    (.setLoops loops)))


//////////////////////////////////////////////////////////////////////////
// Reify a sprite from its frame name
c::Sprite* reifySprite(const sstr &name) {
  return c::Sprite::createWithSpriteFrameName(name);
}

//////////////////////////////////////////////////////////////////////////
// Reify a sprite from its frame name
c::Sprite* createSprite(const sstr &name) {
  return c::Sprite::create( XCFG()->getImage(name));
}

//////////////////////////////////////////////////////////////////////////////
//
c::Sprite* loadSprite(const sstr &fname, const sstr &path) {
  auto sp= c::Sprite::create();
  sp->initWithFile(path + "/" + fname);
  return sp;
}

//////////////////////////////////////////////////////////////////////////
//
const Box4 bbox4(not_null<c::Node*> s) {
  auto z= s->getBoundingBox();
  return Box4(z.origin.y + z.size.height,
      z.origin.x + z.size.width,
      z.origin.y,
      z.origin.x);
  /*
    GetTop(s),
    GetRight(s),
    GetBottom(s),
    GetLeft(s) */
}

//////////////////////////////////////////////////////////////////////////
//
void prelude() {
  runEx(XCFG()->prelude());
}

//////////////////////////////////////////////////////////////////////////
//
void runEx(not_null<c::Scene*> ns) {
  run(ns, CC_CSV(c::Float, "SCENE_DELAY"));
}

//////////////////////////////////////////////////////////////////////////
//
void run(not_null<c::Scene*> ns, float delay) {
  CC_DTOR()->replaceScene(
      c::TransitionCrossFade::create(delay, ns));
}

//////////////////////////////////////////////////////////////////////////
//
void run(not_null<c::Scene*> ns) {
  CC_DTOR()->replaceScene(ns);
}

//////////////////////////////////////////////////////////////////////////
//
void pushEx(not_null<c::Scene*> ns) {
  push(ns, CC_CSV(c::Float, "SCENE_DELAY"));
}

//////////////////////////////////////////////////////////////////////////
//
void push(not_null<c::Scene*> ns, float delay) {
  CC_DTOR()->pushScene(
      c::TransitionCrossFade::create(delay, ns));
}

//////////////////////////////////////////////////////////////////////////
//
void push(not_null<c::Scene*> ns) {
  CC_DTOR()->pushScene(ns);
}

//////////////////////////////////////////////////////////////////////////
//
bool isTransitioning() {
  return dynamic_cast<c::TransitionScene*>(
      CC_DTOR()->getRunningScene()) != CC_NIL;
}

//////////////////////////////////////////////////////////////////////////
// Find size of this sprite
//
const CCT_SZ calcSize(const sstr &frame) {
  //return reifySprite(frame)->getContentSize();
  return reifySprite(frame)->boundingBox().size;
}

//////////////////////////////////////////////////////////////////////////
// Calculate halves of width and height of this sprite
//
const CCT_SZ halfHW(not_null<c::Node*> s) {
  //auto z= s->getContentSize();
  auto z= s->getBoundingBox().size;
  return CCT_SZ(z.width * 0.5, z.height * 0.5);
}

//////////////////////////////////////////////////////////////////////////
// Reify a rectangle from this sprite
//
const CCT_RT bbox(not_null<c::Node*> s) {
  return s->getBoundingBox();
  /*
  return CCT_RT(GetLeft(s),
                 GetBottom(s),
                 GetWidth(s),
                 GetHeight(s)); */
}

//////////////////////////////////////////////////////////////////////////
//
float getHeight(not_null<c::Node*> s) {
  //return s->getContentSize().height * s->getScaleY();
  return s->getBoundingBox().size.height;
}

//////////////////////////////////////////////////////////////////////////
//
float getWidth(not_null<c::Node*> s) {
  //return s->getContentSize().width * s->getScaleX();
  return s->getBoundingBox().size.width;
}

//////////////////////////////////////////////////////////////////////////
//
float getContentHeight(not_null<c::Node*> s) {
  return s->getContentSize().height;
}

//////////////////////////////////////////////////////////////////////////
//
float getContentWidth(not_null<c::Node*> s) {
  return s->getContentSize().width;
}

//////////////////////////////////////////////////////////////////////////
//
static float get_XXX(not_null<c::Node*> s, float px, float bound) {
  //auto w= s->getContentSize().width;
  auto w= s->getBoundingBox().size.width;
  auto a= s->getAnchorPoint().x;
  return px + (bound - a) * w ;
}

//////////////////////////////////////////////////////////////////////////
//
static float get_YYY(not_null<c::Node*> s, float py, float bound) {
  //auto h= s->getContentSize().height;
  auto h= s->getBoundingBox().size.height;
  auto a= s->getAnchorPoint().y;
  return py + (bound - a) * h ;
}

//////////////////////////////////////////////////////////////////////////
//
float getLeft(not_null<c::Node*> s) {
  return get_XXX(s, s->getPosition().x, anchorL().x);
}

//////////////////////////////////////////////////////////////////////////
//
float getRight(not_null<c::Node*> s) {
  return get_XXX(s, s->getPosition().x, anchorR().x);
}

//////////////////////////////////////////////////////////////////////////
//
float getBottom(not_null<c::Node*> s) {
  return get_YYY(s, s->getPosition().y, anchorB().y);
}

//////////////////////////////////////////////////////////////////////////
//
float getTop(not_null<c::Node*> s) {
  return get_YYY(s, s->getPosition().y, anchorT().y);
}

//////////////////////////////////////////////////////////////////////////
// Get the x pos of the center of the visible screen
//
float centerX() { return center().x; }

//////////////////////////////////////////////////////////////////////////
// Get the y pos of the center of the visible screen.
//
float centerY() { return center().y; }

//////////////////////////////////////////////////////////////////////////
// Get the center of the visible screen
//
const CCT_PT center() {
  auto rc = visRect();
  return CCT_PT(rc.origin.x + HWZ(rc.size), rc.origin.y + HHZ(rc.size));
}

//////////////////////////////////////////////////////////////////////////
// Get the screen height
//
float screenHeight() { return screen().height; }

//////////////////////////////////////////////////////////////////////////
// Get the screen width
//
float screenWidth() { return screen().width; }

//////////////////////////////////////////////////////////////////////////
// Get the visible screen rectangle
//
const CCT_RT visRect() {
  return CC_DTOR()->getOpenGLView()->getVisibleRect();
}

//////////////////////////////////////////////////////////////////////////////
//
const CCT_SZ visSize() {
  return CC_DTOR()->getOpenGLView()->getVisibleRect().size;
}

//////////////////////////////////////////////////////////////////////////
// Get the visible screen box
//
const Box4 visBox() {
  auto vr = CC_DTOR()->getOpenGLView()->getVisibleRect();
  return Box4(
    vr.origin.y + vr.size.height,
    vr.origin.x + vr.size.width,
    vr.origin.y,
    vr.origin.x
  );
}

//////////////////////////////////////////////////////////////////////////
// Get the actual window/frame size.
//
const CCT_SZ screen() {
  return CC_DTOR()->getOpenGLView()->getFrameSize();
}

//////////////////////////////////////////////////////////////////////////
// Get the actual screen center.
//
const CCT_PT scenter() {
  auto sz = screen();
  return CCT_PT(HWZ(sz), HHZ(sz));
}

//////////////////////////////////////////////////////////////////////////
// Get the center of this box.
//
const CCT_PT vboxMID(const Box4 &box) {
  return CCT_PT(box.left + (box.right-box.left) * 0.5,
              box.bottom + (box.top-box.bottom) * 0.5);
}

//////////////////////////////////////////////////////////////////////////
// Test if this box is hitting boundaries
// rect.x & y are center positioned
//
// If hit, the new position and velocities
// are returned
//
bool traceEnclosure(float dt, const Box4 &bbox,
    const Box4 &rect, const CCT_V2 &vel,
    CCT_PT &outPos, CCT_V2 &outVel) {

  auto sz= rect.top-rect.bottom;//height
  auto sw= rect.right-rect.left;//width
  auto y = rect.bottom+(sz*0.5) + dt * vel.y;// new y
  auto x = rect.left+(sw*0.5) + dt * vel.x;// new x
  auto vx= vel.x;
  auto vy= vel.y;
  auto hit=false;

  if (y + sz > bbox.top) {
    //hitting top wall
    y = bbox.top - sz;
    vy = -vy;
    hit=true;
  }
  else
  if (y - sz < bbox.bottom) {
    //hitting bottom wall
    y = bbox.bottom + sz;
    vy = -vy;
    hit=true;
  }

  if (x + sw > bbox.right) {
    //hitting right wall
    x = bbox.right - sw;
    vx = -vx;
    hit=true;
  }
  else
  if (x - sw < bbox.left) {
    //hitting left wall
    x = bbox.left + sw;
    vx = -vx;
    hit=true;
  }

  outPos.x=x;
  outPos.y=y;
  outVel.x=vx;
  outVel.y=vy;

  return hit;
}

//////////////////////////////////////////////////////////////////////////////
//
bool isIntersect(const Box4 &a1, const Box4 &a2) {
  return ! (a1.left > a2.right ||
            a2.left > a1.right ||
            a1.top < a2.bottom ||
            a2.top < a1.bottom);
}

//////////////////////////////////////////////////////////////////////////
// Get the sprite from the frame cache using its id (e.g. #ship)
//
c::SpriteFrame* getSpriteFrame(const sstr &frameid, const CCT_RT &r) {
  auto f= CC_SCAC()->getSpriteFrameByName(frameid);
  f->setRect(r);
  return f;
}

//////////////////////////////////////////////////////////////////////////
// Get the sprite from the frame cache using its id (e.g. #ship)
//
c::SpriteFrame* getSpriteFrame(const sstr &frameid) {
  return CC_SCAC()->getSpriteFrameByName(frameid);
}

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorC() { return CCT_PT::ANCHOR_MIDDLE;}

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorT() { return CCT_PT::ANCHOR_MIDDLE_TOP;}

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorTR() { return CCT_PT::ANCHOR_TOP_RIGHT; }

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorR() { return CCT_PT::ANCHOR_MIDDLE_RIGHT;}

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorBR() { return CCT_PT::ANCHOR_BOTTOM_RIGHT; }

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorB() { return CCT_PT::ANCHOR_MIDDLE_BOTTOM; }

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorBL() { return CCT_PT::ANCHOR_BOTTOM_LEFT; }

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorL() { return CCT_PT::ANCHOR_MIDDLE_LEFT; }

//////////////////////////////////////////////////////////////////////////
//
const CCT_PT anchorTL() { return CCT_PT::ANCHOR_TOP_LEFT; }

//////////////////////////////////////////////////////////////////////////
// not used for now.
//
void resolveElastic(
    not_null<c::Node*> obj1,
    CCT_V2 &vel1,
    not_null<c::Node*> obj2, CCT_V2 &vel2) {

  auto pos2 = obj2->getPosition();
  auto pos1= obj1->getPosition();
  auto sz2= CC_CSIZE(obj2);
  auto sz1= CC_CSIZE(obj1);
  auto hh1= HHZ(sz1);
  auto hw1= HWZ(sz1);
  auto x = pos1.x;
  auto y= pos1.y;
  auto bx2 = bbox4(obj2);
  auto bx1 = bbox4(obj1);

  // coming from right
  if (bx1.left < bx2.right && bx2.right < bx1.right) {
    vel2.x = - fabs(vel2.x);
    vel1.x = fabs(vel1.x);
    x= getRight(obj2) + hw1;
  }
  else
  // coming from left
  if (bx1.right > bx2.left && bx1.left < bx2.left) {
    vel1.x = - fabs(vel1.x);
    vel2.x = fabs(vel2.x);
    x= getLeft(obj2) - hw1;
  }
  else
  // coming from top
  if (bx1.bottom < bx2.top && bx1.top > bx2.top) {
    vel2.y = - fabs(vel2.y);
    vel1.y = fabs(vel1.y);
    y= getTop(obj2) + hh1;
  }
  else
  // coming from bottom
  if (bx1.top > bx2.bottom && bx2.bottom > bx1.bottom) {
    vel1.y = - fabs(vel1.y);
    vel2.y = fabs(vel2.y);
    y= getBottom(obj2) - hh1;
  }
  else {
    return;
  }
  //obj1->updatePosition(x,y);
}

//////////////////////////////////////////////////////////////////////////////
//
const CCT_PT clamp(const CCT_PT& loc, const CCT_SZ &sz, const Box4 &world) {
  auto hh = HHZ(sz);
  auto hw = HWZ(sz);
  auto x= loc.x;
  auto y= loc.y;

  if ((loc.x + hw) > world.right) {
    x = world.right - hw;
  }
  if ((loc.x - hw) < world.left) {
    x = world.left + hw;
  }
  if ((loc.y - hh) < world.bottom) {
    y = world.bottom + hh;
  }
  if ((loc.y + hh) > world.top) {
    y = world.top - hh;
  }

  return CCT_PT(x,y);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
const CCT_PT clamp(const CCT_PT &cur, const Box4 &bx) {
  return ccpClamp(cur, c::ccp(bx.left, bx.bottom), c::ccp(bx.right, bx.top));
}

//////////////////////////////////////////////////////////////////////////////
//
int randInt(int upper) {
    //auto r=cocos2d::rand_0_1();
    //CCLOG("rand01 ===== %f", r);
  return (int) floor( cocos2d::rand_0_1() * upper);
}

//////////////////////////////////////////////////////////////////////////////
//
float randFloat(float upper) {
  return cocos2d::rand_0_1() * upper;
}

//////////////////////////////////////////////////////////////////////////////
//
int randSign() {
    return (::rand() % 2) == 1 ? 1 : -1;
  /*
  int n=  cocos2d::rand_0_1() * 10;
  switch (n) {
    case 0: case 2: case 4: case 6: case 8: return 1;
    default: return -1;
  }
  */
}

//////////////////////////////////////////////////////////////////////////////
//
float rand() {
  return cocos2d::rand_0_1();
}

//////////////////////////////////////////////////////////////////////////////
//
float degToRad(float deg) {
  return deg * M_PI / 180;
}

//////////////////////////////////////////////////////////////////////////////
//
long long timeInMillis() {
  return c::utils::getTimeInMilliseconds();
}

//////////////////////////////////////////////////////////////////////////////
//
const CCT_PT calcXY(float angle, float hypot) {
  // quadrants =  4 | 1
  //             --------
  //              3 | 2
  float theta, q, x, y;
  if (angle >= 0 && angle <= 90) {
    theta = degToRad(90 - angle);
    x = cos(theta);
    y = sin(theta);
    q=1;
  }
  else
  if (angle >= 90 && angle <= 180 ) {
    theta = degToRad(angle - 90);
    x = cos(theta);
    y =  - sin(theta);
    q=2;
  }
  else
  if (angle >= 180 && angle <= 270) {
    theta = degToRad(270 - angle);
    x = - cos(theta);
    y = - sin(theta);
    q=3;
  }
  else
  if (angle >= 270 && angle <= 360) {
    theta= degToRad(angle - 270);
    x = - cos(theta);
    y = sin(theta);
    q=4;
  }
  else {
  }

  return CCT_PT( x * hypot, y * hypot);
}

//////////////////////////////////////////////////////////////////////////////
//
VOIDFN throttle(VOIDFN func, int wait) {
  long long ww= (long long)wait;
  long long previous = 0;
  return [=]() mutable {
    auto now = timeInMillis();
    if (previous==0)
    { previous = now; }
    auto remaining = ww - (now - previous);
    if (remaining <= 0 || remaining > ww) {
      previous = now;
      func();
    }
  };
}

//////////////////////////////////////////////////////////////////////////////
//
void testCollide(not_null<f::FPool*> p1, not_null<ecs::Node*> node) {
  if (node->status())
    p1->foreach([=](f::Poolable* _p1) {
      auto e1= (ecs::Node*) _p1;
      testCollide(e1,node);
    });
}

//////////////////////////////////////////////////////////////////////////////
//
void testCollide(not_null<f::FPool*> p1, not_null<f::FPool*> p2) {
  p1->foreach([=](f::Poolable* _p1) {
  p2->foreach([=](f::Poolable* _p2) {
    auto e2= (ecs::Node*) _p2;
    auto e1= (ecs::Node*) _p1;
    testCollide(e1,e2);
  });
  });
}

//////////////////////////////////////////////////////////////////////////////
//
void testCollide(not_null<ecs::Node*> e1, not_null<ecs::Node*> e2) {
  auto s2= CC_GEC(f::CPixie,e2.get(),"f/CPixie");
  auto s1= CC_GEC(f::CPixie,e1.get(),"f/CPixie");
  if (e2->status() &&
      e1->status() &&
      collide(s2,s1)) {
    auto h2= CC_GEC(f::CHealth,e2.get(),"f/CHealth");
    auto h1= CC_GEC(f::CHealth,e1.get(),"f/CHealth");
    h2->hurt();
    h1->hurt();
  }
}

//////////////////////////////////////////////////////////////////////////////
//
void hibernate(not_null<ecs::Node*> node) {
  auto s=CC_GEC(f::CPixie,node.get(),"f/CPixie");
  if (s) { s->deflate(); }
  node->yield();
}

//////////////////////////////////////////////////////////////////////////////
//
void resurrect(not_null<ecs::Node*> node, float x, float y) {
  auto h=CC_GEC(f::CHealth,node.get(),"f/CHealth");
  auto s=CC_GEC(f::CPixie,node.get(),"f/CPixie");
  if (s) { s->inflate(x,y); }
  if (h) { h->reset(); }
  node->take();
}

//////////////////////////////////////////////////////////////////////////////
//
void kumakaze(not_null<ecs::Node*> node) {
  auto h=CC_GEC(f::CHealth,node.get(),"f/CHealth");
  if (h) {
    h->curHP = 0;
  }
}

//////////////////////////////////////////////////////////////////////////////
//
void resurrect(not_null<ecs::Node*> node) {
  auto h=CC_GEC(f::CHealth,node.get(),"f/CHealth");
  auto s=CC_GEC(f::CPixie,node.get(),"f/CPixie");
  if (s) { s->inflate(); }
  if (h) { h->reset(); }
  node->take();
}

//////////////////////////////////////////////////////////////////////////////
//
void resolveNodes(not_null<f::FPool*> pool) {
  pool->foreach([=](f::Poolable *p) {
    if (p->status()) {
      auto ht=CC_GEC(f::CHealth,p,"f/CHealth");
      if (N_NIL(ht) &&
          !ht->alive())
        hibernate(PCAST(ecs::Node,p));
    }
  });
}


NS_END
NS_END





