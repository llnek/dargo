
(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.elmo.core.CCSX
  (:require ["kirby"
             :as ky :refer []]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pop "" [] (.popScene cc/director))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn randomPos "" [node]
  (var wb (visBox))
  (.setPosition node
                (randInt wb.right)
                (randInt wb.top)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mkHMenu "" [items pad] (mkMenu items #f pad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mkVMenu "" [items pad] (mkMenu items #t pad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- mkMenu
  "menu-items should be same size"
  [items vert? pad]
  (var menu (cc/Menu.create))
  (each #(.addChild menu %) items)
  (if vert?
    (.alignItemsVerticallyWithPadding menu pad)
    (.alignItemsHorizontallyWithPadding menu pad))
  menu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn wrapMenu "" [item]
  (doto (cc/Menu.create)
    (.addChild item)
    (.setPosition 0 0)
    (.setAnchorPoint (anchorBL))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isDesktop "" [] (raise! "TBD"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn splitHexColor "" [rgbstr]
  (var f /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
       s /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/
       len (n# rgbstr)
       arr (or (.exec f color)
               (.exec s color)))
  (when arr
    (set! arr (slice arr 1))
    (map #(parseInt (str "0x" %))
         (if (= len 4) (map #(str % %) arr) arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn colorRGB "" [rgbstr]
  (var [r g b] (splitHexColor rgbstr)) (cc/color r g b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sfxMusic "" [music repeat?]
  (var url (xcfg/getMusic music))
  (try
    (.playMusic cc.audioEngine url repeat?)
    (catch e
      (cc.warn (cc/formatStr
                 "Failed to play music: %s" music)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sfxPlay "" [sound]
  (var url (xcfg/getEffect sound))
  (try
    (.playEffect cc.audioEngine url)
    (catch e
      (cc.warn (cc/formatStr
                 "Failed to play sound: %s" sound)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pauseEffects "" [] (.pauseAllEffects cc.audioEngine))
(defn pauseMusic "" [] (.pauseMusic cc.audioEngine))
(defn pauseAudio "" [] (pauseEffects) (pauseMusic))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resumeEffects "" [] (.resumeAllEffects cc.audioEngine))
(defn resumeMusic "" [] (.resumeMusic cc.audioEngine))
(defn resumeAudio "" [] (resumeEffects) (resumeMusic))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn stopEffects "" [] (.stopAllEffects cc.audioEngine))
(defn stopMusic "" [] (.stopMusic cc.audioEngine))
(defn stopAudio "" [] (stopEffects) (stopMusic))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn calcOffsets "" [sz]
  (cc/size (/ sz.width *golden-ratio*)
           (/ sz.height *golden-ratio*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reifySpriteBatch "" [name]
  (->> (xcfg/getImage name)
       (.addImage cc.textureCache)
       (cc/SpriteBatchNode.createWithTexture )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createAudioMItems "" [&[onIcon ovIcon]]
  (set! ovIcon (opt?? ovIcon "sound_off.png")
        onIcon (opt?? onIcon "sound_on.png"))
  [(createMenuBtn ovIcon ovIcon)
   (createMenuBtn onIcon onIcon)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createAudioMImages "" [&[onIcon ovIcon]]
  (set! ovIcon (opt?? ovIcon "sound_off.png")
        onIcon (opt?? onIcon "sound_on.png"))
  [(createMenuImg ovIcon ovIcon)
   (createMenuImg onIcon onIcon)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn calcDist "" [node-a node-b]
  (cc.pDistance (.getPosition node-a)
                (.getPosition node-b)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn normalize "" [node-a node-b]
  (cc/pNormalize (cc/pSub (.getPosition node-b)
                          (.getPosition node-a))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createMenuText "" [fnt point txt color]
  (var z (createTTFLabel fnt point txt))
  (.setColor z color)
  (cc/MenuItemLabel.create z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createMenuText "" [fnt txt color]
  (var z (createBMFLabel fnt txt))
  (.setColor z color)
  (cc/MenuItemLabel.create z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createMenuImg "" [normal & [selected]]
  (set! selected (opt?? selected normal))
  (cc/MenuItemSprite.create
    (createSprite normal) (createSpeite selected)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createMenuBtn "" [normal & [selected]]
  (set! selected (opt?? selected normal))
  (cc/MenuItemImage.create
    (xcfg/getImage normal) (xcfg/getImage selected)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pointInBox?
  "Test if this point is inside this rectangle"
  [box & [x y]]
  (when-not (number? x)
    ;x is a point and y is not set
    (set! y x.y x x.x))
  (and (>= x box.left)
       (<= x box.right)
       (>= y box.bottom) (<= y box.top)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createBMFLabel "" [fnt txt & [x y]]
  (var f (.createWithBMFont cc/Label
                            (xcfg/getFont fnt) txt))
  (.setOpacity f (* 0.9 255))
  (when (or (number? x)
            (some? x))
    (if-not (number? x)
      (set! y x.y x x.x))
    (.setPosition f x y))
  f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createTTFLabel "" [fnt sz txt & [x y]]
  (var f (.createWithTTF cc/Label
                         txt
                         (xcfg/getFont fnt) sz))
  (when (or (number? x)
            (some? x))
    (if-not (number? x)
      (set! y x.y x x.x))
    (.setPosition f x y))
  f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn collide?
  "Test collision of 2 sprites"
  [node-a node-b]
  (if (and node-a node-b)
    (.intersectsRect (bbox node-a)
                     (bbox node-b)) #f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setDevRes "" [x y policy]
  (-> (.getOpenGLView cc.director)
      (.setDesignResolutionSize x y policy)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isTapped? "" [node tap]
  (<= (.distance tap (.getPosition node))
      (* 0.8 (get-in (.getBoundingBox node)
                     [:size :width]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deltaX "" [node-a node-b]
  (- (.getPositionX node-a) (.getPositionX node-b)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deltaY "" [node-a node-b]
  (- (.getPositionY node-a) (.getPositionY node-b)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isPortrait? "" []
  (var s (screen)) (> s.height s.width))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn readPlist "" [url]
  (var s (.getStringFromFile jsb/fileUtils url))
  (.parse cc/plistParser s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn readJson "" [url]
  (var s (.getStringFromFile jsb/fileUtils url))
  (JSON/parse s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment
(defn outOfBound? "" [node B]
  (if node (outOfBound (bbox4 node) B) #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn outOfBound? "" [a B]
  (or (> a.left B.right)
      (< a.top B.bottom)
      (< a.right B.left)
      (> a.bottom B.top)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn scaleSize "" [z scale]
  (cc/size (* z.width scale) (* z.height scale)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn undoTimer "" [tm] (if tm (.release tm)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createTime
  "Reify a timer action"
  [par millis]
  (var t (.create cc/DelayTime (/ millis 1000.0)))
  (.retain t)
  (.runAction par t)
  t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn timerDone? "" [t] (if t (.isDone t) #f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createAnimation "" [dpu restore? loops]
  (doto (.create cc/Animation)
    (.setRestoreOriginalFrame restore?)
    (.setDelayPerUnit dpu)
    (.setLoops loops)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createSprite
  "Reify a sprite from its frame name"
  [name]
  (.createWithSpriteFrameName cc/Sprite name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createImage
  "Reify a sprite from its frame name"
  [name]
  (.create cc/Sprite (xcfg/getImage name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn loadSprite
  ""
  [fname path]
  (var sp (.create cc/Sprite))
  (.initWithFile sp (str path "/" fname))
  sp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn bbox4 "" [s]
  (var {:keys [origin size]} (.getBoundingBox s))
  (Box4 (+ origin.y size.height)
        (+ origin.x size.width)
        origin.y
        origin.x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn prelude "" [] (runEx (xcfg/prelude)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn runEx "" [s]
  (run s (xcfg/cstVal :SCENE-DELAY)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn run "" [s & [delay]]
  (if (number? delay)
    (->> (.create cc/TransitionCrossFade delay s)
         (.replaceScene cc.director))
    (.replaceScene cc.director)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn push "" [s & [delay]]
  (if (number? delay)
    (set! delay (xcfg/cstVal :SCENE-DELAY)))
  (.pushScene cc.director
      (.create cc/TransitionCrossFade delay s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isTransitioning? "" []
  (some? (.getRunningScene cc.director)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn calcSize
  "Find size of this sprite"
  [frame]
  (get (.boundingBox (createSprite frame)) :size))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn halfHW
  "Calculate halves of width and height of this sprite"
  [s]
  (var z (get (.getBoundingBox s) :size))
  (cc/size (* 0.5 z.width) (* 0.5 z.height)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn bbox
  "Reify a rectangle from this sprite"
  [s]
  (.getBoundingBox s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getHeight "" [s]
  (get-in (.getBoundingBox s) [:size :height]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getWidth "" [s]
  (get-in (.getBoundingBox s) [:size :width]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getContentHeight "" [s]
  (.-height (.getContentSize s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getContentWidth "" [s]
  (.-width (.getContentSize s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn get-XXX "" [s px bound]
  (var w (get-in (.getBoundingBox s) [:size :width])
       a (.-x (.getAnchorPoint s)))
  (+ px (* w (- bound a))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn get-YYY "" [s py bound]
  (var h (get-in (.getBoundingBox s) [:size :height])
       a (.-y (.getAnchorPoint s)))
  (+ py (* h (- bound a))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getLeft "" [s]
  (get-XXX s (.-x (.getPosition s)) (.-x (anchorL))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getRight "" [s]
  (get-XXX s (.-x (.getPosition s)) (.-x (anchorR))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getBottom "" [s]
  (get-YYY s (.-y (.getPosition s)) (.-y (anchorB))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getTop "" [s]
  (get-YYY s (.-y (.getPosition s)) (.-y (anchorT))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn centerX
  "Get the x pos of the center of the visible screen"
  []
  (.-x (center)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn centerY
  "Get the y pos of the center of the visible screen."
  []
  (.-y (center)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn center
  "Get the center of the visible screen"
  []
  (var {:keys [origin size]} (visRect))
  (cc/p (+ origin.x (HWZ size))
        (+ origin.y (HHZ size))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn screenHeight
  "Get the screen height" [] (.-height (screen)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn screenWidth
  "Get the screen width" [] (.-width (screen)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn visRect
  "Get the visible screen rectangle" []
  (-> cc.director
      (.getOpenGLView) (.getVisibleRect)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn visSize "" []
  (get (-> cc.director
           (.getOpenGLView)
           (.getVisibleRect)) :size))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn visBox
  "Get the visible screen box" []
  (var {:keys [origin size]}
       (-> cc.director
           (.getOpenGLView)(.getVisibleRect)))
  (Box4 (+ origin.y size.height)
        (+ origin.x size.width) origin.y origin.x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn screen
  "Get the actual window/frame size." []
  (-> cc.director
      (.getOpenGLView)(.getFrameSize)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn scenter
  "Get the actual screen center." []
  (var sz (screen))
  (cc/p (HWZ sz) (HHZ sz)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vboxMID
  "Get the center of this box." [box]
  (cc/p (+ box.left (* 0.5 (- box.right box.left)))
        (+ box.bottom (* 0.5 (- box.top box.bottom)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn traceEnclosure
  "Test if this box is hitting boundaries
  rect.x & y are center positioned
  If hit, the new position and velocities
  are returned"
  [dt bbox rect vel]

  (var sz (- rect.top rect.bottom) ;height
       sw (- rect.right rect.left) ;width
       y (+ rect.bottom
            (* sz 0.5) (* dt vel.y)) ;new y
       x (+ rect.left
            (* sw 0.5) (* dt vel.x)) ;new x
       vx vel.x vy vel.y hit? #f)

  (cond
    (> (+ y sz) bbox.top) ;;hitting top wall
    (set! y (- bbox.top sz)
          vy (- vy)
          hit? #t)
    (< (- y sz) bbox.bottom) ;;hitting bottom wall
    (set! y (+ bbox.bottom sz)
          vy (- vy)
          hit? #t))
  (cond
    (> (+ x sw) bbox.right) ;;hitting right wall
    (set! x (- bbox.right  sw)
          vx (- vx)
          hit? #t)
    (< (- x sw) bbox.left) ;;hitting left wall
    (set! x  (+ bbox.left  sw)
          vx (- vx)
          hit? #t))
  ;return new position and velocity
  {:hit?  hit?
   :pos (cc/p x y)
   :vel (cc/p vx vy)})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isIntersect? "" [a1 a2]
  (not (or (> a1.left a2.right)
           (> a2.left a1.right)
           (< a1.top a2.bottom)
           (< a2.top a1.bottom))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const *scac*
(fn [&xs]
(var that cc.spriteFrameCache)
(that.getSpriteFrameByName.apply that xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getSpriteFrame
  "Get the sprite from the frame cache
  using its id (e.g. #ship)"
  [frameid & [rect]]
  (var f (*scac* frameid))
  (if (some? rect) (.setRect f rect)) f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn anchorC "" [] (cc/p 0.5 0.5))
(defn anchorT "" [] (cc/p 0.5 1))
(defn anchorTR "" [] (cc/p 1 1))
(defn anchorR "" [] (cc/p 1 0.5))
(defn anchorBR "" [] (cc/p 1 0))
(defn anchorB "" [] (cc/p 0.5 0))
(defn anchorBL "" [] (cc/p 0 0))
(defn anchorL "" [] (cc/p 0 0.5))
(defn anchorTL "" [] (cc/p 0 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const *csize* (fn [s]
                 (.-size (.getBoundingBox s))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resolveElastic
  "not used for now."
  [obj1 vel1 obj2 vel2]
  (var pos2 (.getPosition obj2)
       pos1 (.getPosition obj1)
       sz2 (*csize* obj2)
       sz1 (*csize* obj1)
       hh1 (HHZ sz1)
       hw1 (HWZ sz1)
       x pos1.x
       y pos1.y
       bx2 (bbox4 obj2)
       bx1 (bbox4 obj1))
  (cond
    ;; coming from right
    (and (< bx1.left bx2.right)
         (< bx2.right bx1.right))
    (do (assoc! vel2 :x (- (fabs vel2.x)))
        (assoc! vel1 :x (fabs vel1.x))
        (set! x (+ (getRight obj2) hw1)))

    ;; coming from left
    (and (> bx1.right bx2.left)
         (< bx1.left bx2.left))
    (do (assoc! vel1 :x (- (fabs vel1.x)))
        (assoc! vel2 :x (fabs vel2.x))
        (set! x (- (getLeft obj2) hw1)))
    ;; coming from top
    (and (< bx1.bottom bx2.top)
         (> bx1.top bx2.top))
    (do (assoc! vel2 :y (- (fabs vel2.y)))
        (assoc! vel1 :y (fabs vel1.y))
        (set! y (+ (getTop obj2) hh1)))
    ;; coming from bottom
    (and (> bx1.top bx2.bottom)
         (> bx2.bottom bx1.bottom))
    (do (assoc! vel1 :y (- (fabs vel1.y)))
        (assoc! vel2 :y (fabs vel2.y))
        (set! y (- (getBottom obj2) hh1))))
  ;(.updatePosition obj1 x y)
  nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn clamp3 "" [loc sz world]
  (var hh (HHZ sz)
       hw (HWZ sz)
       x loc.x
       y loc.y)
  (if (> (+ loc.x hw) world.right)
    (set! x (- world.right hw)))
  (if (< (- loc.x hw) world.left)
    (set! x (+ world.left hw)))
  (if (< (- loc.y hh) world.bottom)
    (set! y (+ world.bottom hh)))
  (if (> (+ loc.y hh) world.top)
    (set! y (- world.top hh)))
  (cc/p x y))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn clamp2 "" [cur bx]
  (cc/pClamp cur
             (cc/p bx.left bx.bottom)
             (cc/p bx.right bx.top)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn randInt "" [upper]
  (Math/floor (* upper (cc/ramdom0To1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn randFloat
  "" [upper] (* upper (cc/ramdom0To1)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn randSign "" []
  (if (> (cc/ramdom0To1) 0.5) 1 -1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn rand "" [] (cc/ramdom0To1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn degToRad
  "" [deg] (* deg (/ Math/PI 180)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn timeInMillis "" [] (.getTime (new Date)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn calcXY
  "quadrants =  4 | 1
               --------
                3 | 2"
  [angle hypot]

  (var~ theta q x y)
  (cond
    (and (>= angle 0)
         (<= angle 90))
    (set! theta (degToRad (- 90 angle))
          x (cos theta)
          y (sin theta)
          q 1)
    (and (>= angle 90)
         (<= angle 180))
    (set! theta (degToRad (- angle 90))
          x (cos theta)
          y (- (sin theta))
          q 2)
    (and (>= angle 180)
         (<= angle 270))
    (set! theta (degToRad (- 270 angle))
          x (- (cos theta))
          y (- (sin theta))
          q 3)
    (and (>= angle 270)
         (<= angle 360))
    (set! theta (degToRad (- angle 270))
          x (- (cos theta))
          y (sin theta)
          q 4))
  (cc/p (* x hypot) (* y hypot)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn throttle "" [func wait]
  (var previous  0)
  (fn []
    (var now (timeInMillis))
    (if (zero? previous)
      (set! previous now))
    (var remaining (- wait (- now previous)))
    (when (or (<= remaining 0)
              (> remaining wait))
      (set! previous now)
      (func))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn testCollideNode "" [p1 node]
  (when (get node :status)
    (.foreach p1
              (fn [e]
                (testCollideNodes e node)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn testCollidePools "" [p1 p2]
  (.foreach p1
            (fn [e1]
              (.foreach p2
                        (fn [e2]
                          (testCollideNodes e1 e2))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn testCollideNodes "" [e1 e2]
  (var s2 (.get e2 :pixie)
       s1 (.get e1 :pixie))
  (when (and (get e2 :status)
             (get e1 :status)
             (collide s2 s1))
    (.hurt (get e2 :health))
    (.hurt (get e1 :health))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hibernate "" [node]
  (var s (get node :pixie))
  (if s (.deflate s))
  (.yield node))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resurrect "" [node x y]
  (var h (get node :health)
       s (get node :pixie))
  (if s (.inflate s x y))
  (if h (.reset h))
  (.take node))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn kumakaze "" [node]
  (var h (get node :health))
  (if h
    (assoc! h :curHP 0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resurrect "" [node]
  (var h (get node :health)
       s (get node :pixie))
  (if s (.inflate s))
  (if h (.reset h))
  (.take node))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resolveNodes "" [pool]
  (.foreach pool
            (fn [e]
              (when (get e :status)
                (var ht (get e :health))
                (if (and ht
                         (not (get ht :alive?)))
                  (hibernate e))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF




