;; Copyright (c) 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.elmo.x2d.XNode

  (:require ["kirby"
             :as K :refer []]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;#define __decl_get_iid(x) virtual int getIID() { return x; }
;#define __decl_update() virtual void update(float);
;#define __decl_deco_ui() virtual void decoUI();

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype SCTX []
  (constructor [] (assign! this :count 1)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addAudioIcons
  "Add a toggle for sound on & off."
  [audios anchor pos & [selector target]]
  (var a (if selector
           (new cc/MenuItemToggle (_1 audios) (_2 audios) selector target)
           (new cc/MenuItemToggle (_1 audios) (_2 audios))))
  (.setSelectedIndex a 0)
  (.setAnchorPoint a anchor)
  (doto (new cc/Menu a) (.setPosition pos)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addAtlas "" [co atlasName & [zx]]
  (var a (cx/createSpriteBatch name))
  (if-not (number? zx)
    (.addChild co a)
    (.addChild co a zx))
  (update-in! co [:atlases] assoc! atlasName a) a)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addAtlasFrame "" [co atlasName frame pos & [zx tag]]
  (var tt (cx/createSprite frame))
  (set! zx (opt?? zx 0))
  (set! tag (opt?? tag 0))
  (.setPosition tt pos)
  (addAtlasItem co atlasName tt zx tag))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addFrame "" [co frame pos & [zx tag]]
  (var tt (cx/createSprite frame))
  (set! zx (opt?? zx 0))
  (set! tag (opt?? tag 0))
  (.setPosition tt pos)
  (addItem co tt zx tag))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addAtlasItem "" [co atlas item & [zx tag]]
  (var p (get co :atlases))
  (if (sprite? item)
    (.setBatchNode item p))
  (addItem p item zx tag))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addItem "" [co item & [zx tag]]
  (set! zx (opt?? zx 0))
  (set! tag (opt?? tag 0))
  (.addChild co item zx tag))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn centerImage "" [co image & [zx tag]]
  (var s (new cc/Sprite image))
  (set! zx (opt?? zx 0))
  (set! tag (opt?? tag 0))
  (.setPosition s (cx/centerPoint))
  (.addChild co s zx tag)
  s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeAtlasAll "" [co atlasName]
  (if-some [p (get-in co [:atlases atlasName])] (.removeAllChildren p)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeAll "" [co] (.removeAllChildren co))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeItem "" [co item]
  (if item (.removeFromParent item)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype XScene [cc/Scene]

  (constructor [ &[physics?] ]
    (super)
    (assign! this
             :usePhysics? (if physics? #t #f)))

  (addLayer [y & [zx]]
    (addChild this y zx (.getIID y)))

  (getLayer [tag]
    (.getChildByTag this tag))

  (init []
    (var ok? (if (get this :usePhysics?)
               (.initWithPhysics this) (super)))
    (if ok? (.decoUI this))
    ok?))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype XLayer [cc/Layer]

  (initEx [par & [zx]]
    (var ok? (.init this))
    (when ok?
      (.addLayer par this zx)
      (.decoPre this)
      (.decoUI this)
      (.decoPost this)) ok?)

  (keyPoll [key]
    (if (and (>= key 0)
             (< key 256)) (nth this._keys key) #f))
  (disableListeners []
    (try (.setKeyboardEnabled this false) (catch e nil))
    (try (.setMouseEnabled this false) (catch  e nil))
    (try (.setTouchEnabled this false) (catch e nil))
    (.fill this._keys false))

  (enableListeners []
    (.disableListeners this)
    (try (if (cx/isDesktop?)
           (.setKeyboardEnabled this true))
         (catch e
          (cc.log "failed to init-keys")))
    (try (if (cx/isDesktop?) (.setMouseEnabled this true))
         (catch e
           (cc.log "failed to init-mouse")))
    (try (if-not (cx/isDesktop?) (.setTouchEnabled this true))
         (catch e
           (cc.log "failed to init-touch"))))

  (onTouchesBegan [ts evt]
    (if (= this._tMode
           cc/Touch.DispatchMode.ALL_AT_ONCE)
      (.onTouchStart this ts)
      (.onTouchStart this (_1 ts))))

  (onTouchesMoved [ts evt]
    (if (= this._tMode cc/Touch.DispatchMode.ALL_AT_ONCE)
      (.onTouchMotion this ts)
      (.onTouchMotion this (_1 ts))))

  (onTouchesEnded [ts evt]
    (if (= this._tMode cc/Touch.DispatchMode.ALL_AT_ONCE)
      (.onTouchEnd this ts)
      (.onTouchEnd this (_1 ts))))

  (onMouseMotion [loc] )

  (onTouchStart [ts]
    (raise! "you need to implement this!"))

  (onTouchStart [tap] #t)

  (onTouchEnd [ts]
    (raise! "you need to implement this!"))

  (onTouchEnd [tap] )

  (onTouchMotion [ts]
    (raise! "you need to implement this!"))

  (onKeyPressed [key evt]
    (if (and (>= key 0)
             (< key (.size this._keys)))
      (aset this->_keys key #t)))

  (onKeyReleased [key evt]
    (if (and (>= key 0)
             (< key (.size this._keys)))
      (aset this->_keys key #f)))

  (onMouseDown [evt]
    (when-not this._mouseDown
      (assign! this
               :_mouseTarget #f
               :_mouseDown #t)
      (if (= (.getMouseButton evt) @@_mouseBtn)
        (assign! this
                 :_mouseTarget
                 (.onMouseStart this (.getLocationInView evt))))))

  (onMouseUp [evt]
    (if (= (.getMouseButton evt) @@_mouseBtn)
      (.onMouseClick this (.getLocationInView evt)))
    (assign! this :_mouseTarget #f :_mouseDown #f))

  (onMouseStart [loc] #t)

  (onMouseClick [loc] )

  (onMouseMove [evt]
    (if (and @@_mouseTarget
             (= @@_mouseBtn (.getMouseButton evt)))
      (.onMouseMotion this (.getLocationInView evt))))

  (onMouseScroll [evt] )

  (setMouseEnabled [enabled?]
    (when-not (= @@_mouseEnabled enabled?)
      (assign! this :_mouseEnabled enabled?)
      (if enabled?
        (when (nil? @@_mouseListener)
          (var n (.create cc/EventListenerMouse))
          (assign! this :_mouseListener n)
          (set! n.onMouseScroll (onMouseScroll this))
          (set! n.onMouseMove (onMouseMove this))
          (set! n.onMouseUp (onMouseUp this))
          (set! n.onMouseDown (onMouseDown this))
          (.addEventListenerWithSceneGraphPriority @@eventDispatcher n this))
        (do (.removeEventListener @@_eventDispatcher @@_mouseListener)
            (set! this._mouseListener nil)))))

  (constructor []
    (assign! this
             :tMode cc/Touch.DispatchMode.ONE_BY_ONE
             ;;:tMode cc/Touch.DispatchMode.ALL_AT_ONCE
             :mouseListener nil
             :mouseBtn MOUSE_BUTTON_LEFT
             :mouseEnabled? #f
             :mouseTarget? #f
             :mouseDown? #f
             :keys (fillArray 256 #f)))

  (isMouseEnabled? [] @@mouseEnabled)
  (getIID [] 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const GMode (object :ONE 1 :TWO 2 :NET 3 :NICHTS -1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype GCX [SCTX]
  (constructor [mode &[odin]]
    (super)
    (assign! this :mode mode :odin odin)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype GameScene [XScene]

  (constructor [cfg &[physics?]]
    (super physics?)
    (assign! this :cfg cfg))

  (getCurLevel []
    (.getLevel @@cfg @@level))

  (getLevelCfg []
    (.getLevelCfg @@cfg @@level))

  (getPool [key] (get @@pools key))

  (createPool [key]
    (assoc! @@pools key (new ecs/EntityPool )))

  (resetPools [] (resetMap! @@pools))

  (getMode [] (.-mode @@context))

  (isOnline? [] (some? (.-odin @@context)))

  (getEnclosureRect [] (cx/visRect))

  (getEnclosureBox [] (cx/visBox))

  (constructor []
    (assign! this
             :pools {}
             :msgQ {}
             :state 0
             :level 1))

  (play [] (set! @@state 911))
  (isLive? [] (> @@state 0))
  (stop! [] (set! @@state 0))

  (getLevel [] @@level)

  (sendMsg [topic] (sendMsgEx topic nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype GameLayer [XLayer]

  (decoPost []
    (when @@engine
      (.ignite @@engine))
    (.scheduleUpdate this))

  (decoPre []
    (cx/resumeAudio #t #t)
    (.enableListeners this))

  (surcease []
    (.disableListeners this)
    (cx/pauseAudio #t #t)
    (.unscheduleUpdate this))

  (update [dt]
    (if (and (not (cx/isTransitioning?))
             (.isLive MainGameScene)
             (some? @@engine))
      (.update @@engine dt)))

  (constructor []
    (assign! this :engine nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype XLives [cc/Node]

  (reduce [ &[x]]
    (set! x (opt?? x 1))
    (while (> x 0)
      (when (> @@icons.size 0)
        ;;auto it= _icons.back(); it->removeFromParent(); _icons.pop_back();
        nil)
      (-= x 1)
      (-= @@curLives 1)))

  (reset []
    (each #(.removeFromParent %) @@icons)
    (resetVec! @@icons)
    (set! @@curLives @@totalLives))

  (resurrect []
    (.reset this)
    (.drawLives this))

  (drawLives []
    (var~ v x y)
    (dotimes [n @@curLives]
      (set! v (cx/createSprite @@frameId))
      (.setScale v @@scale)
      (when (zero? n)
        (set! @@lifeSize (cx/scaleSize (CC_CSIZE v) @@scale)
              y (- (.-y @@refPt) (HHZ @@lifeSize))
              x (+ (.-x @@refPt) (HWZ @@lifeSize))))
      (.setPosition v x y)
      (addChild this v)
      (conj! @@icons v)
      (if (> @@dir 0)
        (+= x (* 1.2 (.-width @@lifeSize)))
        (-= x (* 1.2 (.-width @@lifeSize))))))

  (initLives [frame lives x y & [scale d]]
    (set! @@totalLives lives
          @@frameId frame
          @@curLives 0
          @@dir (opt?? d 1)
          @@scale (opt?? scale 1)
          @@refPt (cc/p x y))
    (.reset this)
    (.drawLives this))

  (constructor []
    (assign! this
             :icons []
             :lifeSize (cc/size 0 0)
             :refPt (cc/p 0 0)
             :frameId ""
             :scale 1
             :dir 1
             :totalLives 0
             :curLives 0))

  (isDead? [] (<= @@curLives 0))
  (getLives [] @@curLives))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF



