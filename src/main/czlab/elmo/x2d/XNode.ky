;; Copyright (c) 2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.elmo.x2d.XNode

  (:require ["kirby"
             :as K :refer []]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;#define __decl_get_iid(x) virtual int getIID() { return x; }
;#define __decl_update() virtual void update(float);
;#define __decl_deco_ui() virtual void decoUI();

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro class "" [name super &xs]
  `(const ~name (.extend ~super (object ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype SCTX []
  (constructor [] (assign! this :count 1)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addAudioIcons
  "Add a toggle for sound on & off."
  [audios anchor pos & [selector target]]
  (var a (if selector
           (new cc/MenuItemToggle (_1 audios) (_2 audios) selector target)
           (new cc/MenuItemToggle (_1 audios) (_2 audios))))
  (.setSelectedIndex a 0)
  (.setAnchorPoint a anchor)
  (doto (new cc/Menu a) (.setPosition pos)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addAtlas "" [co atlasName & [zx]]
  (var a (cx/createSpriteBatch name))
  (if-not (number? zx)
    (.addChild co a)
    (.addChild co a zx))
  (update-in! co [:atlases] assoc! atlasName a) a)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addAtlasFrame "" [co atlasName frame pos & [zx tag]]
  (var tt (cx/createSprite frame))
  (set! zx (opt?? zx 0))
  (set! tag (opt?? tag 0))
  (.setPosition tt pos)
  (addAtlasItem co atlasName tt zx tag))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addFrame "" [co frame pos & [zx tag]]
  (var tt (cx/createSprite frame))
  (set! zx (opt?? zx 0))
  (set! tag (opt?? tag 0))
  (.setPosition tt pos)
  (addItem co tt zx tag))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addAtlasItem "" [co atlas item & [zx tag]]
  (var p (get co :atlases))
  (if (sprite? item)
    (.setBatchNode item p))
  (addItem p item zx tag))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addItem "" [co item & [zx tag]]
  (set! zx (opt?? zx 0))
  (set! tag (opt?? tag 0))
  (.addChild co item zx tag))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn centerImage "" [co image & [zx tag]]
  (var s (new cc/Sprite image))
  (set! zx (opt?? zx 0))
  (set! tag (opt?? tag 0))
  (.setPosition s (cx/centerPoint))
  (.addChild co s zx tag)
  s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeAtlasAll "" [co atlasName]
  (if-some [p (get-in co [:atlases atlasName])] (.removeAllChildren p)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeAll "" [co] (.removeAllChildren co))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeItem "" [co item]
  (if item (.removeFromParent item)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(class XScene
       cc/Scene
       ctor (fn [] (._super this))
       init (fn []
              (._super this)
              (.deco this))
       addLayer (fn [y & [zx]]
                  (addItem this y zx (.getIID y)))
       getLayer (fn [tag] (.getChildByTag this tag)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(class XLayer
       cc/Layer
       initEx
       (fn [par & [zx]]
         (when (.init this)
           (.addLayer par this zx)
           (.preDeco this)
           (.deco this)
           (.postDeco this) #t))
       keyPoll
       (fn [k]
         (if (and (>= k 0)
                  (< k 256)) (nth @@keys k) #f))
       disableListeners
       (fn []
         (trye! (.setKeyboardEnabled this #f))
         (trye! (.setMouseEnabled this #f))
         (trye! (.setTouchEnabled this #f)) (.fill @@keys #f))
       enableListeners
       (fn []
         (.disableListeners this)
         (cond
           (cx/isDesktop?)
           (do (.setMouseEnabled this #t)
               (.setKeyboardEnabled this #t))
           :else
           (.setTouchEnabled this #t)))
       onTouchesBegan
       (fn [ts evt]
         (if (= @@tMode
                cc/EventListener.TOUCH_ALL_AT_ONCE)
           (.onTouchStart this ts)
           (.onTouchStart this (_1 ts))))
       onTouchesMoved
       (fn [ts evt]
         (if (= @@tMode
                cc/EventListener.TOUCH_ALL_AT_ONCE)
           (.onTouchMotion this ts)
           (.onTouchMotion this (_1 ts))))
       onTouchesEnded
       (fn [ts evt]
         (if (= @@tMode
                cc/EventListener.TOUCH_ALL_AT_ONCE)
           (.onTouchEnd this ts)
           (.onTouchEnd this (_1 ts))))
       onTouchStart (fn [ts] (raise! "you need to implement this!"))
       onTouchStart (fn [tap] #t)
       onTouchEnd (fn [ts] (raise! "you need to implement this!"))
       onTouchEnd (fn [tap] )
       onTouchMotion (fn [ts] (raise! "you need to implement this!"))
       onKeyPressed
       (fn [k evt]
         (if (and (>= k 0)
                  (< k (n# @@keys))) (aset @@keys k #t)))
       onKeyReleased
       (fn [k evt]
         (if (and (>= k 0)
                  (< k (n# @@keys))) (aset @@keys k #f)))
       onMouseDown
       (fn [evt]
         (when-not @@mouseDown?
           (assign! this
                    :mouseTarget? #f :mouseDown? #t)
           (if (= (.getButton evt) @@mouseBtn)
             (assign! this
                      :mouseTarget?
                      (.onMouseStart this (.getLocationInView evt))))))
       onMouseUp
       (fn [evt]
         (if (= (.getButton evt) @@mouseBtn)
           (.onMouseClick this (.getLocationInView evt)))
         (assign! this :mouseTarget? #f :mouseDown? #f))
       onMouseStart (fn [loc] #t)
       onMouseClick (fn [loc] )
       onMouseScroll (fn [evt] )
       onMouseMotion (fn [loc] )
       onMouseMove
       (fn [evt]
         (if (and @@mouseTarget?
                  (= @@mouseBtn (.getButton evt)))
           (.onMouseMotion this (.getLocationInView evt))))
       setMouseEnabled
       (fn [enabled?]
         (when-not (= @@mouseEnabled? enabled?)
           (set! @@mouseEnabled? enabled?)
           (if enabled?
             (when (nil? @@mouseListener)
               (var me this cb #(.onMouseXXX me %))
               (set! @@mouseListener
                     (.create cc/EventListener
                              `{event cc/EventListener.MOUSE
                                onMouseScroll cb
                                onMouseMove cb
                                onMouseUp cb
                                onMouseDown cb}))
               (.addListener cc/eventManager @@mouseListener))
             (do (.removeListener cc/eventManager @@mouseListener)
                 (nil! @@mouseListener)))))
       ctor
       (fn []
         (assign! this
                  ;:tMode cc/EventListener.TOUCH_ALL_AT_ONCE
                  :tMode cc/EventListener.TOUCH_ONE_BY_ONE
                  :mouseListener nil
                  :mouseBtn cc/EventMouse.BUTTON_LEFT
                  :mouseEnabled? #f
                  :mouseTarget? #f
                  :mouseDown? #f
                  :keys (fillArray 256 #f)))
       isMouseEnabled? (fn [] @@mouseEnabled)
       getIID (fn [] 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const GMode (object :ONE 1 :TWO 2 :NET 3 :NICHTS -1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deftype GCX [SCTX]
  (constructor [mode &[odin]]
    (super)
    (assign! this :mode mode :odin odin)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(class GameScene
       XScene
       ctor (fn [cfg]
              (._super this)
              (assign! this
                       :cfg cfg
                       :pools {}
                       :msgQ {}
                       :state 0
                       :level 1))
       getCurLevel (fn [] (.getLevel @@cfg @@level))
       getLevelCfg (fn [] (.getLevelCfg @@cfg @@level))
       getPool (fn [p] (get @@pools p))
       createPool (fn [p] (assoc! @@pools p (new ecs/EntityPool )))
       resetPools (fn [] (K/resetMap! @@pools))
       getMode (fn [] (.-mode @@context))
       isOnline? (fn [] (some? (.-odin @@context)))
       getEnclosureRect (fn [] (cx/visRect))
       getEnclosureBox (fn [] (cx/visBox))
       play (fn [] (set! @@state 911))
       isLive? (fn [] (> @@state 0))
       stop! (fn [] (set! @@state 0))
       getLevel (fn [] @@level)
       sendMsg (fn [topic] (sendMsgEx topic nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(class GameLayer
       XLayer
       decoPost (fn []
                  (when @@engine
                    (.ignite @@engine))
                  (.scheduleUpdate this))
       preDeco (fn []
                 (cx/resumeAudio #t #t)
                 (.enableListeners this))
       surcease (fn []
                  (.disableListeners this)
                  (cx/pauseAudio #t #t)
                  (.unscheduleUpdate this))
       update (fn [dt]
                (if (and (not (cx/isTransitioning?))
                         (.isLive MainGameScene)
                         (some? @@engine))
                  (.update @@engine dt)))
       ctor (fn [] (assign! this :engine nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(class XLives
       cc/Node
       reduce (fn [&[x]]
                (set! x (opt?? x 1))
                (while (> x 0)
                  (when (> @@icons.size 0)
                    ;;auto it= _icons.back(); it->removeFromParent(); _icons.pop_back();
                    nil)
                  (-= x 1)
                  (-= @@curLives 1)))
       reset (fn []
               (each #(.removeFromParent %) @@icons)
               (K/resetVec! @@icons)
               (set! @@curLives @@totalLives))
       resurrect (fn [] (.reset this) (.drawLives this))
       drawLives (fn []
                   (var~ v x y)
                   (dotimes [n @@curLives]
                     (set! v (cx/createSprite @@frameId))
                     (.setScale v @@scale)
                     (when (zero? n)
                       (set! @@lifeSize (cx/scaleSize (CC_CSIZE v) @@scale)
                             y (- (.-y @@refPt) (HHZ @@lifeSize))
                             x (+ (.-x @@refPt) (HWZ @@lifeSize))))
                     (.setPosition v x y)
                     (.addChild this v)
                     (conj! @@icons v)
                     (if (> @@dir 0)
                       (+= x (* 1.2 (.-width @@lifeSize)))
                       (-= x (* 1.2 (.-width @@lifeSize))))))
       initLives (fn [frame lives x y & [scale d]]
                   (set! @@totalLives lives
                         @@frameId frame
                         @@curLives 0
                         @@dir (opt?? d 1)
                         @@scale (opt?? scale 1)
                         @@refPt (cc/p x y))
                   (.reset this)
                   (.drawLives this))
       ctor (fn [] (assign! this
                            :icons []
                            :lifeSize (cc/size 0 0)
                            :refPt (cc/p 0 0)
                            :frameId ""
                            :scale 1
                            :dir 1
                            :totalLives 0
                            :curLives 0))
       isDead? (fn [] (<= @@curLives 0))
       getLives (fn [] @@curLives))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF



