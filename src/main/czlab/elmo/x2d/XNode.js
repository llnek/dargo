/*Auto generated by Kirby v1.0.0 - Thu Feb 08 2018 23:03:58 GMT-0800 (PST)
  czlab.elmo.x2d.XNode
{"doc" "" "author" "Kenneth Leung"}
*/

const K = require("kirby");
const kirbystdlibref = require("kirby");
const __module_namespace__ = "czlab.elmo.x2d.XNode";
class SCTX {
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [constructor] in file: XNode.ky, line: 28
  constructor() {
    (
    this["count"] = 1);
    return this;
  }
}
////////////////////////////////////////////////////////////////////////////////
//fn: [addAudioIcons] in file: XNode.ky, line: 31
//Add a toggle for sound on & off.
const addAudioIcons = function(audios, anchor, pos) {
  let GS__3 = Array.prototype.slice.call(arguments, 3);
  let selector = GS__3[0];
  let target = GS__3[1];
  let a = (selector ?
    new cc.MenuItemToggle(kirbystdlibref.getProp(audios, 0), kirbystdlibref.getProp(audios, 1), selector, target) :
    new cc.MenuItemToggle(kirbystdlibref.getProp(audios, 0), kirbystdlibref.getProp(audios, 1)));
  a.setSelectedIndex(0);
  a.setAnchorPoint(anchor);
  return (function() {
    let GS__4 = new cc.Menu(a);
    GS__4.setPosition(pos);
    return GS__4;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addAtlas] in file: XNode.ky, line: 42
const addAtlas = function(co, atlasName) {
  let GS__5 = Array.prototype.slice.call(arguments, 2);
  let zx = GS__5[0];
  let a = cx.createSpriteBatch(name);
  if ( (!((typeof (zx) === "number"))) ) {
    co.addChild(a);
  } else {
    co.addChild(a, zx);
  }
  update_DASH_in_BANG(co, ["atlases"], assoc_BANG, atlasName, a);
  return a;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addAtlasFrame] in file: XNode.ky, line: 50
const addAtlasFrame = function(co, atlasName, frame, pos) {
  let GS__6 = Array.prototype.slice.call(arguments, 4);
  let zx = GS__6[0];
  let tag = GS__6[1];
  let tt = cx.createSprite(frame);
  (zx = opt_QMRK__QMRK(zx, 0));
  (
  tag = opt_QMRK__QMRK(tag, 0));
  tt.setPosition(pos);
  return addAtlasItem(co, atlasName, tt, zx, tag);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addFrame] in file: XNode.ky, line: 58
const addFrame = function(co, frame, pos) {
  let GS__7 = Array.prototype.slice.call(arguments, 3);
  let zx = GS__7[0];
  let tag = GS__7[1];
  let tt = cx.createSprite(frame);
  (zx = opt_QMRK__QMRK(zx, 0));
  (
  tag = opt_QMRK__QMRK(tag, 0));
  tt.setPosition(pos);
  return addItem(co, tt, zx, tag);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addAtlasItem] in file: XNode.ky, line: 66
const addAtlasItem = function(co, atlas, item) {
  let GS__8 = Array.prototype.slice.call(arguments, 3);
  let zx = GS__8[0];
  let tag = GS__8[1];
  let p = kirbystdlibref.getProp(co, "atlases");
  if (sprite_QMRK(item)) {
    item.setBatchNode(p);
  }
  return addItem(p, item, zx, tag);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addItem] in file: XNode.ky, line: 73
const addItem = function(co, item) {
  let GS__9 = Array.prototype.slice.call(arguments, 2);
  let zx = GS__9[0];
  let tag = GS__9[1];
  (
  zx = opt_QMRK__QMRK(zx, 0));
  (
  tag = opt_QMRK__QMRK(tag, 0));
  return co.addChild(item, zx, tag);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [centerImage] in file: XNode.ky, line: 79
const centerImage = function(co, image) {
  let GS__10 = Array.prototype.slice.call(arguments, 2);
  let zx = GS__10[0];
  let tag = GS__10[1];
  let s = new cc.Sprite(image);
  (zx = opt_QMRK__QMRK(zx, 0));
  (
  tag = opt_QMRK__QMRK(tag, 0));
  s.setPosition(cx.centerPoint());
  co.addChild(s, zx, tag);
  return s;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [removeAtlasAll] in file: XNode.ky, line: 88
const removeAtlasAll = function(co, atlasName) {
  let GS__11 = get_DASH_in(co, ["atlases", atlasName]);
  let p = GS__11;
  if ( (((typeof (GS__11) === "undefined")) || ((GS__11 === null))) ) {
    null;
  } else {
    p.removeAllChildren();
  }
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [removeAll] in file: XNode.ky, line: 92
const removeAll = function(co) {
  return co.removeAllChildren();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [removeItem] in file: XNode.ky, line: 95
const removeItem = function(co, item) {
  if (item) {
    item.removeFromParent();
  }
  return null;
};
const XScene = cc.Scene.extend({
  ctor: function() {
    return this._super();
  },
  init: function() {
    this._super();
    return this.deco();
  },
  addLayer: function(y) {
    let GS__12 = Array.prototype.slice.call(arguments, 1);
    let zx = GS__12[0];
    return addItem(this, y, zx, y.getIID());
  },
  getLayer: function(tag) {
    return this.getChildByTag(tag);
  }
});
const XLayer = cc.Layer.extend({
  initEx: function(par) {
    let GS__13 = Array.prototype.slice.call(arguments, 1);
    let zx = GS__13[0];
    return (this.init() ?
      (function() {
        par.addLayer(this, zx);
        this.preDeco();
        this.deco();
        this.postDeco();
        return true;
      }).call(this) :
      null);
  },
  keyPoll: function(k) {
    return (((k >= 0) && (k < 256)) ?
      kirbystdlibref.getProp(this.keys, k) :
      false);
  },
  disableListeners: function() {
    try {
      this.setKeyboardEnabled(false);
    } catch (ewroewrwe) {
      null;
    }
    try {
      this.setMouseEnabled(false);
    } catch (ewroewrwe) {
      null;
    }
    try {
      this.setTouchEnabled(false);
    } catch (ewroewrwe) {
      null;
    }
    return this.keys.fill(false);
  },
  enableListeners: function() {
    this.disableListeners();
    return (cx.isDesktop_QMRK() ?
      (function() {
        this.setMouseEnabled(true);
        return this.setKeyboardEnabled(true);
      }).call(this) :
      (true ?
        this.setTouchEnabled(true) :
        null));
  },
  onTouchesBegan: function(ts, evt) {
    return ((this.tMode === cc.EventListener.TOUCH_ALL_AT_ONCE) ?
      this.onTouchStart(ts) :
      this.onTouchStart(kirbystdlibref.getProp(ts, 0)));
  },
  onTouchesMoved: function(ts, evt) {
    return ((this.tMode === cc.EventListener.TOUCH_ALL_AT_ONCE) ?
      this.onTouchMotion(ts) :
      this.onTouchMotion(kirbystdlibref.getProp(ts, 0)));
  },
  onTouchesEnded: function(ts, evt) {
    return ((this.tMode === cc.EventListener.TOUCH_ALL_AT_ONCE) ?
      this.onTouchEnd(ts) :
      this.onTouchEnd(kirbystdlibref.getProp(ts, 0)));
  },
  onTouchStart: function(ts) {
    return (function() {
      throw new Error("you need to implement this!");
    }).call(this);
  },
  onTouchStart: function(tap) {
    return true;
  },
  onTouchEnd: function(ts) {
    return (function() {
      throw new Error("you need to implement this!");
    }).call(this);
  },
  onTouchEnd: function(tap) {},
  onTouchMotion: function(ts) {
    return (function() {
      throw new Error("you need to implement this!");
    }).call(this);
  },
  onKeyPressed: function(k, evt) {
    return (((k >= 0) && (k < kirbystdlibref.count(this.keys))) ?
      (this.keys[k] = true) :
      null);
  },
  onKeyReleased: function(k, evt) {
    return (((k >= 0) && (k < kirbystdlibref.count(this.keys))) ?
      (this.keys[k] = false) :
      null);
  },
  onMouseDown: function(evt) {
    return ((!this.mouseDown_QMRK) ?
      (function() {
        (this["mouseTarget?"] = false, this["mouseDown?"] = true);
        return ((evt.getButton() === this.mouseBtn) ?
          (this["mouseTarget?"] = this.onMouseStart(evt.getLocationInView())) :
          null);
      }).call(this) :
      null);
  },
  onMouseUp: function(evt) {
    if ( (evt.getButton() === this.mouseBtn) ) {
      this.onMouseClick(evt.getLocationInView());
    }
    return (this["mouseTarget?"] = false, this["mouseDown?"] = false);
  },
  onMouseStart: function(loc) {
    return true;
  },
  onMouseClick: function(loc) {},
  onMouseScroll: function(evt) {},
  onMouseMotion: function(loc) {},
  onMouseMove: function(evt) {
    return ((this.mouseTarget_QMRK && (this.mouseBtn === evt.getButton())) ?
      this.onMouseMotion(evt.getLocationInView()) :
      null);
  },
  setMouseEnabled: function(enabled_QMRK) {
    return ((!(this.mouseEnabled_QMRK === enabled_QMRK)) ?
      (function() {
        (
        this.mouseEnabled_QMRK = enabled_QMRK);
        return (enabled_QMRK ?
          (((this.mouseListener === null)) ?
            (function() {
              let me = this;
              let cb = function() {
                let ____args = Array.prototype.slice.call(arguments);
                return me.onMouseXXX(____args[0]);
              };
              (this.mouseListener = cc.EventListener.create({
                event: cc.EventListener.MOUSE,
                onMouseScroll: cb,
                onMouseMove: cb,
                onMouseUp: cb,
                onMouseDown: cb
              }));
              return cc.eventManager.addListener(this.mouseListener);
            }).call(this) :
            null) :
          (function() {
            cc.eventManager.removeListener(this.mouseListener);
            return (this.mouseListener = null);
          }).call(this));
      }).call(this) :
      null);
  },
  ctor: function() {
    return (this["tMode"] = cc.EventListener.TOUCH_ONE_BY_ONE, this["mouseListener"] = null, this["mouseBtn"] = cc.EventMouse.BUTTON_LEFT, this["mouseEnabled?"] = false, this["mouseTarget?"] = false, this["mouseDown?"] = false, this["keys"] = fillArray(256, false));
  },
  isMouseEnabled_QMRK: function() {
    return this.mouseEnabled;
  },
  getIID: function() {
    return 1;
  }
});
const GMode = {
  "ONE": 1,
  "TWO": 2,
  "NET": 3,
  "NICHTS": -1
};
class GCX extends SCTX {
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [constructor] in file: XNode.ky, line: 227
  constructor(mode) {
    let GS__14 = Array.prototype.slice.call(arguments, 1);
    let odin = GS__14[0];
    super();
    (this["mode"] = mode, this["odin"] = odin);
    return this;
  }
}
const GameScene = XScene.extend({
  ctor: function(cfg) {
    this._super();
    return (this["cfg"] = cfg, this["pools"] = (new Map([])), this["msgQ"] = (new Map([])), this["state"] = 0, this["level"] = 1);
  },
  getCurLevel: function() {
    return this.cfg.getLevel(this.level);
  },
  getLevelCfg: function() {
    return this.cfg.getLevelCfg(this.level);
  },
  getPool: function(p) {
    return kirbystdlibref.getProp(this.pools, p);
  },
  createPool: function(p) {
    return (kirbystdlibref.assoc_BANG(this.pools, p, new ecs.EntityPool()));
  },
  resetPools: function() {
    return K.resetMap_BANG(this.pools);
  },
  getMode: function() {
    return this.context.mode;
  },
  isOnline_QMRK: function() {
    return some_QMRK(this.context.odin);
  },
  getEnclosureRect: function() {
    return cx.visRect();
  },
  getEnclosureBox: function() {
    return cx.visBox();
  },
  play: function() {
    return (this.state = 911);
  },
  isLive_QMRK: function() {
    return (this.state > 0);
  },
  stop_BANG: function() {
    return (this.state = 0);
  },
  getLevel: function() {
    return this.level;
  },
  sendMsg: function(topic) {
    return sendMsgEx(topic, null);
  }
});
const GameLayer = XLayer.extend({
  decoPost: function() {
    if (this.engine) {
      this.engine.ignite();
    }
    return this.scheduleUpdate();
  },
  preDeco: function() {
    cx.resumeAudio(true, true);
    return this.enableListeners();
  },
  surcease: function() {
    this.disableListeners();
    cx.pauseAudio(true, true);
    return this.unscheduleUpdate();
  },
  update: function(dt) {
    return (((!cx.isTransitioning_QMRK()) && MainGameScene.isLive() && some_QMRK(this.engine)) ?
      this.engine.update(dt) :
      null);
  },
  ctor: function() {
    return (this["engine"] = null);
  }
});
const XLives = cc.Node.extend({
  reduce: function() {
    let GS__15 = Array.prototype.slice.call(arguments, 0);
    let x = GS__15[0];
    (
    x = opt_QMRK__QMRK(x, 1));
    return (function() {
      for (let ____break = false; ((!____break) && (x > 0));) {
        if ( (this.icons.size > 0) ) {
          null;
        }
        (x -= 1);
        (
        this.curLives -= 1);
      }
    }).call(this);
  },
  reset: function() {
    this.icons.forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return ____args[0].removeFromParent();
    });
    K.resetVec_BANG(this.icons);
    return (this.curLives = this.totalLives);
  },
  resurrect: function() {
    this.reset();
    return this.drawLives();
  },
  drawLives: function() {
    let v,
      x,
      y;
    return (function() {
      for (let n = 0, GS__16 = this.curLives, ____break = false; ((!____break) && (n < GS__16)); n = (n + 1)) {
        (
        v = cx.createSprite(this.frameId));
        v.setScale(this.scale);
        if (( (n === 0) )) {
          (this.lifeSize = cx.scaleSize(CC_CSIZE(v), this.scale), y = (this.refPt.y - HHZ(this.lifeSize)), x = (this.refPt.x + HWZ(this.lifeSize)));
        }
        v.setPosition(x, y);
        this.addChild(v);
        conj_BANG(this.icons, v);
        if ( (this.dir > 0) ) {
          (
          x += (1.2 * this.lifeSize.width));
        } else {
          (
          x -= (1.2 * this.lifeSize.width));
        }
      }
    }).call(this);
  },
  initLives: function(frame, lives, x, y) {
    let GS__17 = Array.prototype.slice.call(arguments, 4);
    let scale = GS__17[0];
    let d = GS__17[1];
    (this.totalLives = lives, this.frameId = frame, this.curLives = 0, this.dir = opt_QMRK__QMRK(d, 1), this.scale = opt_QMRK__QMRK(scale, 1), this.refPt = cc.p(x, y));
    this.reset();
    return this.drawLives();
  },
  ctor: function() {
    return (this["icons"] = [], this["lifeSize"] = cc.size(0, 0), this["refPt"] = cc.p(0, 0), this["frameId"] = "", this["scale"] = 1, this["dir"] = 1, this["totalLives"] = 0, this["curLives"] = 0);
  },
  isDead_QMRK: function() {
    return (this.curLives <= 0);
  },
  getLives: function() {
    return this.curLives;
  }
});
const ____macros = {
  "class": "(macro* class (name super & xs) (syntax-quote (const (unquote name) (.extend (unquote super) (object (splice-unquote xs))))))"
};
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.elmo.x2d.XNode",
    macros: ____macros
  },
  SCTX: SCTX,
  addAudioIcons: addAudioIcons,
  addAtlas: addAtlas,
  addAtlasFrame: addAtlasFrame,
  addFrame: addFrame,
  addAtlasItem: addAtlasItem,
  addItem: addItem,
  centerImage: centerImage,
  removeAtlasAll: removeAtlasAll,
  removeAll: removeAll,
  removeItem: removeItem,
  XScene: XScene,
  XLayer: XLayer,
  GMode: GMode,
  GCX: GCX,
  GameScene: GameScene,
  GameLayer: GameLayer,
  XLives: XLives
};