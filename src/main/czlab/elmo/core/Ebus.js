/*Auto generated by Kirby v1.0.0 - Wed Feb 07 2018 02:01:07 GMT-0800 (PST)
  

*/

const K = require("kirby");
const opt_QMRK__QMRK = K["opt_QMRK__QMRK"];
const atom = K["atom"];
const mapcat = K["mapcat"];
const get_DASH_in = K["get_DASH_in"];
const merge = K["merge"];
const str = K["str"];
const update_DASH_in_BANG = K["update_DASH_in_BANG"];
const not_DASH_empty = K["not_DASH_empty"];
const inc = K["inc"];
const reset_BANG = K["reset_BANG"];
const swap_BANG = K["swap_BANG"];
const deref = K["deref"];
const contains_QMRK = K["contains_QMRK"];
const assoc_BANG = K["assoc_BANG"];
const dissoc_BANG = K["dissoc_BANG"];
const kirbystdlibref = require("kirby");
const __module_namespace__ = "czlab.basal.core.EBus";
var _SEED = atom(0);
////////////////////////////////////////////////////////////////////////////////
//fn: [nextSEQ] in file: Ebus.ky, line: 23
const nextSEQ = function() {
  return swap_BANG(_SEED, inc);
};
var re_DASH_space = /\s+/;
var re_DASH_slash = /\//;
var re_DASH_dot = /\./;
////////////////////////////////////////////////////////////////////////////////
//fn: [split*] in file: Ebus.ky, line: 31
const split_STAR = function(topic) {
  return (((typeof (topic) === "string")) ?
    topic.split(re_DASH_dot).filter(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return not_DASH_empty(____args[0]);
    }) :
    []);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [mkSubSCR] in file: Ebus.ky, line: 37
const mkSubSCR = function(topic, listener, options) {
  if ( (!(((typeof (listener) === "function")))) ) {
    throw Error("Precondition failed");
  } else {
    null;
  }
  return (function() {
    let GS__3 = options;
    let repeat_QMRK = GS__3["repeat?"];
    return merge((new Map([["action", listener]])), (new Map([["id", ["s#", nextSEQ()].join("")], ["repeat?", repeat_QMRK], ["async?", false], ["topic", topic], ["status", [1]]])));
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [mkLevelNode] in file: Ebus.ky, line: 48
const mkLevelNode = function() {
  return (new Map([["levels",(new Map([]))], ["subcs",(new Map([]))]]));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [mkTreeNode] in file: Ebus.ky, line: 49
const mkTreeNode = function() {
  return (new Map([["topics",(new Map([]))], ["subcs",(new Map([]))]]));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addOneSub] in file: Ebus.ky, line: 52
const addOneSub = function(node, sub) {
  return update_DASH_in_BANG(node, ["subcs"], assoc_BANG, kirbystdlibref.getProp(sub, "id"), sub);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [remOneSub] in file: Ebus.ky, line: 56
const remOneSub = function(node, sub) {
  return update_DASH_in_BANG(node, ["subcs"], dissoc_BANG, kirbystdlibref.getProp(sub, "id"));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [interleavePath] in file: Ebus.ky, line: 60
const interleavePath = function(paths) {
  return mapcat(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return ["levels", ____args[0]];
  }, paths);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [listen] in file: Ebus.ky, line: 63
//For each topic, subscribe to it.
const listen = function(root, qos, topics, listener, options) {
  let r = (topics || "").trim().split(re_DASH_space).filter(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return not_DASH_empty(____args[0]);
  }).map(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return addTopic(root, qos, mkSubSCR(____args[0], listener, options));
  });
  return ((1 === kirbystdlibref.count(r)) ?
    kirbystdlibref.getProp(r, 0) :
    r);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [run] in file: Ebus.ky, line: 75
const run = function(subcs, topic, msg) {
  return (function() {
    let GS__4 = subcs;
    for (let GS__6 = 0, GS__5 = false, ____break = false; ((!____break) && ((!GS__5) && (GS__6 < GS__4.length))); GS__6 = (GS__6 + 1)) {
      let GS__7 = kirbystdlibref.getProp(GS__4, GS__6);
      let z = GS__7[1];
      let GS__8 = z;
      let repeat_QMRK = GS__8["repeat?"];
      let action = GS__8["action"];
      let status = GS__8["status"];
      if ( (!true) ) {
        (
        GS__5 = true);
      } else {
        null;
      }
      if ( ((!GS__5) && ((kirbystdlibref.getProp(status, 0) > 0))) ) {
        action(kirbystdlibref.getProp(z, "topic"), topic, msg);
        if ( (!repeat_QMRK) ) {
          (
          status[0] = -1);
        } else {
          null;
        }
      }
    }
    return null;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [walk] in file: Ebus.ky, line: 83
const walk = function(branch, pathTokens, topic, msg, tst) {
  return (function() {
    let GS__9 = branch;
    let levels = GS__9["levels"];
    let subcs = GS__9["subcs"];
    let GS__10 = pathTokens;
    let p = GS__10[0];
    let more = Array.prototype.slice.call(GS__10, 1);
    let cur = kirbystdlibref.getProp(levels, p);
    let s1 = kirbystdlibref.getProp(levels, "*");
    let s1c = kirbystdlibref.getProp(s1, "levels");
    let s2 = kirbystdlibref.getProp(levels, "**");
    if (s2) {
      if (tst) {
        swap_BANG(tst, inc);
      } else {
        run(kirbystdlibref.getProp(s2, "subcs"), topic, msg);
      }
    }
    if (s1) {
      if ( ((0 === kirbystdlibref.count(more)) && (0 === kirbystdlibref.count(s1c))) ) {
        if (tst) {
          swap_BANG(tst, inc);
        } else {
          run(kirbystdlibref.getProp(s1, "subcs"), topic, msg);
        }
      } else {
        if ( (not_DASH_empty(s1c) && not_DASH_empty(more)) ) {
          walk(s1, more, topic, msg, tst);
        } else {
          null;
        }
      }
    }
    return (cur ?
      (function() {
        return (not_DASH_empty(more) ?
          walk(cur, more, topic, msg, tst) :
          (tst ?
            swap_BANG(tst, inc) :
            run(kirbystdlibref.getProp(cur, "subcs"), topic, msg)));
      }).call(this) :
      null);
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resume*] in file: Ebus.ky, line: 112
const resume_STAR = function(root, hd) {
  let sub = get_DASH_in(root, ["subcs", hd]);
  let st = (sub ?
    kirbystdlibref.getProp(sub, "status") :
    null);
  let sv = (st ?
    kirbystdlibref.getProp(st, 0) :
    -1);
  return ((0 === sv) ?
    (st[0] = 1) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pause*] in file: Ebus.ky, line: 119
const pause_STAR = function(root, hd) {
  let sub = get_DASH_in(root, ["subcs", hd]);
  let st = (sub ?
    kirbystdlibref.getProp(sub, "status") :
    null);
  let sv = (st ?
    kirbystdlibref.getProp(st, 0) :
    -1);
  return (((sv > 0)) ?
    (st[0] = 0) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addOneTopic] in file: Ebus.ky, line: 126
const addOneTopic = function(top, qos, sub) {
  let topic = sub["topic"];
  let id = kirbystdlibref.getProp(sub, "id");
  return (("rbus" == qos) ?
    (function() {
      let path = interleavePath(split_STAR(topic));
      return update_DASH_in_BANG(update_DASH_in_BANG(top, path, addOneSub, sub), ["subcs"], assoc_BANG, id, sub);
    }).call(this) :
    update_DASH_in_BANG(update_DASH_in_BANG(top, ["topics", topic], assoc_BANG, id, sub), ["subcs"], assoc_BANG, id, sub));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addTopic] in file: Ebus.ky, line: 136
const addTopic = function(root, qos, sub) {
  swap_BANG(root, addOneTopic, qos, sub);
  return kirbystdlibref.getProp(sub, "id");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [delTopic] in file: Ebus.ky, line: 140
const delTopic = function(top, qos, sub) {
  let topic = sub["topic"];
  let id = kirbystdlibref.getProp(sub, "id");
  return (("rbus" == qos) ?
    (function() {
      let path = interleavePath(split_STAR(topic));
      return update_DASH_in_BANG(update_DASH_in_BANG(top, path, remOneSub, sub), ["subcs"], dissoc_BANG, id);
    }).call(this) :
    update_DASH_in_BANG(update_DASH_in_BANG(top, ["topics", topic], dissoc_BANG, id), ["subcs"], dissoc_BANG, id));
};
//Pub Sub
class EventBus {
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [constructor] in file: Ebus.ky, line: 152
  constructor(qos, options) {
    let s = (("rbus" == qos) ?
      mkLevelNode() :
      mkTreeNode());
    (this["state"] = atom(s), this["qos"] = qos, this["options"] = (options || (new Map([]))));
    return this;
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [sub*] in file: Ebus.ky, line: 160
  //One time only subscription
  sub_STAR(topics, listener) {
    return listen(this.state, this.qos, topics, listener, merge(this.options, (new Map([["repeat?", false]]))));
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [sub+] in file: Ebus.ky, line: 169
  //Standard subscription
  sub_PLUS(topics, listener) {
    return listen(this.state, this.qos, topics, listener, merge(this.options, (new Map([["repeat?", true]]))));
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [pub] in file: Ebus.ky, line: 178
  //Send a message
  pub(topic, msg) {
    let s = this.state.value;
    return (("rbus" == this.qos) ?
      (function() {
        let GS__13 = split_STAR(topic);
        let tokens = GS__13;
        return ((kirbystdlibref.count(GS__13) > 0) ?
          walk(s, tokens, topic, msg, null) :
          null);
      }).call(this) :
      (function() {
        let GS__14 = get_DASH_in(s, ["topics", topic]);
        let sub = GS__14;
        return ((((typeof (GS__14) === "undefined")) || ((GS__14 === null))) ?
          null :
          run(sub, topic, msg));
      }).call(this));
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [resume] in file: Ebus.ky, line: 188
  //Resume this subscriber
  resume(handle) {
    return resume_STAR(this.state.value, handle);
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [pause] in file: Ebus.ky, line: 193
  //Pause this subscriber
  pause(handle) {
    return pause_STAR(this.state.value, handle);
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [unsub] in file: Ebus.ky, line: 197
  //Remove this subscriber
  unsub(handle) {
    let s = this.state.value;
    let GS__15 = get_DASH_in(s, ["subcs", handle]);
    let x = GS__15;
    if ( (((typeof (GS__15) === "undefined")) || ((GS__15 === null))) ) {
      null;
    } else {
      swap_BANG(s, delTopic, qos, x);
    }
    return null;
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [match?] in file: Ebus.ky, line: 204
  //Internal: test only
  match_QMRK(topic) {
    let s = this.state.value;
    return (("rbus" == this.qos) ?
      (function() {
        let tokens = split_STAR(topic);
        let z = atom(0);
        if (not_DASH_empty(tokens)) {
          walk(s, tokens, topic, null, z);
        }
        return ((z.value > 0));
      }).call(this) :
      contains_QMRK(kirbystdlibref.getProp(s, "topics"), topic));
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [dbg] in file: Ebus.ky, line: 216
  //Internal: test only
  dbg() {
    return K.prn(this.state.value);
  }
  ////////////////////////////////////////////////////////////////////////////////
  //fn: [finz] in file: Ebus.ky, line: 220
  //Remove all
  finz() {
    return (function() {
      let GS__16 = null;
      reset_BANG(this.state, (("rbus" == this.qos) ?
        mkLevelNode() :
        mkTreeNode()));
      return GS__16;
    }).call(this);
  }
}
////////////////////////////////////////////////////////////////////////////////
//fn: [createEventBus] in file: Ebus.ky, line: 228
//A Publish Subscribe event manager.  If subject based is
//used, a more advanced matching scheme will be used - such as
//wild-card matches.
const createEventBus = function() {
  let options = Array.prototype.slice.call(arguments, 0);
  let GS__17 = opt_QMRK__QMRK(options, (new Map([])));
  let subjectBased_QMRK = GS__17["subjectBased?"];
  return new EventBus((subjectBased_QMRK ?
    "rbus" :
    "ebus"), options);
};
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.basal.core.EBus",
    macros: {}
  },
  EventBus: EventBus,
  createEventBus: createEventBus
};