/*Auto generated by Kirby v1.0.0 - Sat Feb 10 2018 02:52:00 GMT-0800 (PST)
  czlab.elmo.x2d.core
{"doc" "" "author" "Kenneth Leung"}
*/

const K = require("kirby");
const kirbystdlibref = require("kirby");
const __module_namespace__ = "czlab.elmo.x2d.core";
////////////////////////////////////////////////////////////////////////////////
//fn: [createSoundToggles] in file: XNode.ky, line: 22
//On/Off toggle for sound.
const createSoundToggles = function(audios, cb, target) {
  let GS__3 = Array.prototype.slice.call(arguments, 3);
  let anchor = GS__3[0];
  let pos = GS__3[1];
  let a = new cc.MenuItemToggle(kirbystdlibref.getProp(audios, 0), kirbystdlibref.getProp(audios, 1), cb, target);
  a.setSelectedIndex(0);
  if (anchor) {
    a.setAnchorPoint(anchor);
  }
  let menu = new cc.Menu(a);
  if (pos) {
    menu.setPosition(pos);
  }
  return menu;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addSSheetNode] in file: XNode.ky, line: 36
const addSSheetNode = function(co, sheet) {
  let GS__4 = Array.prototype.slice.call(arguments, 2);
  let zx = GS__4[0];
  let n = cx.createSSheetNode(get_DASH_in(co.xcfg, ["sheets", sheet]));
  if ( (!((typeof (zx) === "number"))) ) {
    co.addChild(n, sheet);
  } else {
    co.addChild(n, sheet, zx);
  }
  return co;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addSpriteFrame] in file: XNode.ky, line: 44
const addSpriteFrame = function(co, item_QUOT) {
  let GS__5 = Array.prototype.slice.call(arguments, 2);
  let pos = GS__5[0];
  let zx = GS__5[1];
  let tag = GS__5[2];
  let GS__6 = ((Array.isArray(item_QUOT)) ?
    [co.getChildByName(kirbystdlibref.getProp(item_QUOT, 0)), cx.createSprite(kirbystdlibref.getProp(item_QUOT, 1))] :
    (((typeof (item_QUOT) === "string")) ?
      [null, cx.createSprite(item_QUOT)] :
      null));
  let s = GS__6[0];
  let n = GS__6[1];
  if (pos) {
    n.setPosition(pos);
  }
  addItem((s || co), n, zx, tag);
  return n;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addItem] in file: XNode.ky, line: 54
const addItem = function(co, item) {
  let GS__7 = Array.prototype.slice.call(arguments, 2);
  let zx = GS__7[0];
  let tag = GS__7[1];
  if ( ((item instanceof cc.Sprite) && (co instanceof cc.SpriteBatchNode)) ) {
    item.setBatchNode(co);
  }
  (zx = opt_QMRK__QMRK(zx, 0));
  (
  tag = opt_QMRK__QMRK(tag, 0));
  co.addChild(item, zx, tag);
  return item;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [centerImage] in file: XNode.ky, line: 63
const centerImage = function(co, image) {
  let GS__8 = Array.prototype.slice.call(arguments, 2);
  let zx = GS__8[0];
  let tag = GS__8[1];
  let s = new cc.Sprite(image);
  s.setPosition(cx.center());
  addItem(co, s, zx, tag);
  return s;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [removeBatchAll] in file: XNode.ky, line: 68
const removeBatchAll = function(co, sheet) {
  return (function() {
    let GS__9 = null;
    let GS__10 = co.getChildByName(sheet);
    let p = GS__10;
    if ( (((typeof (GS__10) === "undefined")) || ((GS__10 === null))) ) {
      null;
    } else {
      p.removeAllChildren();
    }
    return GS__9;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [removeAll] in file: XNode.ky, line: 72
const removeAll = function(co) {
  co.removeAllChildren();
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [removeItem] in file: XNode.ky, line: 75
const removeItem = function(co, item) {
  return (function() {
    let GS__11 = null;
    if (item) {
      item.removeFromParent();
    }
    return GS__11;
  }).call(this);
};
const XScene = cc.Scene.extend({
  ctor: function() {
    return this._super();
  },
  addLayer: function(y) {
    let GS__12 = Array.prototype.slice.call(arguments, 1);
    let zx = GS__12[0];
    return addItem(this, y, zx, y.getIID());
  },
  getLayer: function(tag) {
    return (((typeof (tag) === "string")) ?
      this.getChildByName(tag) :
      (((typeof (tag) === "number")) ?
        this.getChildByTag(tag) :
        null));
  }
});
const XLayer = cc.Layer.extend({
  init: function(par) {
    let GS__13 = Array.prototype.slice.call(arguments, 1);
    let zx = GS__13[0];
    this._super();
    par.addLayer(this, zx);
    return true;
  },
  keyPoll: function(k) {
    return (((k >= 0) && (k < 256)) ?
      kirbystdlibref.getProp(this.keys, k) :
      false);
  },
  deregListeners: function() {
    return (function() {
      try {
        if (this.cbMouse) {
          cc.eventManager.removeListener(this.cbMouse);
        }
        if (this.cbTouch) {
          cc.eventManager.removeListener(this.cbTouch);
        }
        return (this.cbKey ?
          cc.eventManager.removeListener(this.cbKey) :
          null);
      } catch (e) {
        return (this.cbMouse = null, this.cbTouch = null, this.cbKey = null);
      }
    }).call(this);
  },
  regListeners: function() {
    this.deregListeners();
    return (cx.isDesktop_QMRK() ?
      (function() {
        this.regoMouse();
        return this.regoKeyboard();
      }).call(this) :
      (true ?
        this.regoTouch() :
        null));
  },
  onTouchesBegan: function(ts, evt) {
    return ((this.tMode === cc.EventListener.TOUCH_ALL_AT_ONCE) ?
      this.onTouchStart(ts) :
      this.onTouchStart(kirbystdlibref.getProp(ts, 0)));
  },
  onTouchesMoved: function(ts, evt) {
    return ((this.tMode === cc.EventListener.TOUCH_ALL_AT_ONCE) ?
      this.onTouchMotion(ts) :
      this.onTouchMotion(kirbystdlibref.getProp(ts, 0)));
  },
  onTouchesEnded: function(ts, evt) {
    return ((this.tMode === cc.EventListener.TOUCH_ALL_AT_ONCE) ?
      this.onTouchEnd(ts) :
      this.onTouchEnd(kirbystdlibref.getProp(ts, 0)));
  },
  onTouchStart: function(ts) {
    return (function() {
      throw new Error("you need to implement this!");
    }).call(this);
  },
  onTouchStart: function(tap) {
    return true;
  },
  onTouchEnd: function(ts) {
    return (function() {
      throw new Error("you need to implement this!");
    }).call(this);
  },
  onTouchEnd: function(tap) {},
  onTouchMotion: function(ts) {
    return (function() {
      throw new Error("you need to implement this!");
    }).call(this);
  },
  onKeyPressed: function(k, evt) {
    return (((k >= 0) && (k < kirbystdlibref.count(this.keys))) ?
      (this.keys[k] = true) :
      null);
  },
  onKeyReleased: function(k, evt) {
    return (((k >= 0) && (k < kirbystdlibref.count(this.keys))) ?
      (this.keys[k] = false) :
      null);
  },
  onMouseDown: function(evt) {
    return ((!this.mouseDown_QMRK) ?
      (function() {
        (this["mouseTarget?"] = false, this["mouseDown?"] = true);
        return ((evt.getButton() === this.mouseBtn) ?
          (this["mouseTarget?"] = this.onMouseStart(evt.getLocationInView())) :
          null);
      }).call(this) :
      null);
  },
  onMouseUp: function(evt) {
    if ( (evt.getButton() === this.mouseBtn) ) {
      this.onMouseClick(evt.getLocationInView());
    }
    return (this["mouseTarget?"] = false, this["mouseDown?"] = false);
  },
  onMouseStart: function(loc) {
    return true;
  },
  onMouseClick: function(loc) {},
  onMouseScroll: function(evt) {},
  onMouseMotion: function(loc) {},
  onMouseXXX: function(evt) {},
  onMouseMove: function(evt) {
    return ((this.mouseTarget_QMRK && (this.mouseBtn === evt.getButton())) ?
      this.onMouseMotion(evt.getLocationInView()) :
      null);
  },
  regMouse: function(on_QMRK) {
    if ( (!on_QMRK) ) {
      if (this.cbMouse) {
        cc.eventManager.removeListener(this.cbMouse);
        (
        this.cbMouse = null);
      }
    } else {
      if (( (this.cbMouse === null) )) {
        let me = this;
        let cb = function() {
          let ____args = Array.prototype.slice.call(arguments);
          return me.onMouseXXX(____args[0]);
        };
        (this.cbMouse = cc.EventListener.create({
          event: cc.EventListener.MOUSE,
          onMouseScroll: cb,
          onMouseMove: cb,
          onMouseUp: cb,
          onMouseDown: cb
        }));
        cc.eventManager.addListener(this.cbMouse);
      }
    }
    return this.cbMouse;
  },
  regKeys: function(on_QMRK) {
    if ( (!on_QMRK) ) {
      if (this.cbKeys) {
        cc.eventManager.removeListener(this.cbKeys);
        (
        this.cbKeys = null);
      }
    } else {
      if (( (this.cbKeys === null) )) {
        let me = this;
        let cbf = function() {
          let ____args = Array.prototype.slice.call(arguments);
          return me.onKeyXXX(____args[0], ____args[1], false);
        };
        let cbt = function() {
          let ____args = Array.prototype.slice.call(arguments);
          return me.onKeyXXX(____args[0], ____args[1], true);
        };
        (this.cbKeys = cc.EventListener.create({
          event: cc.EventListener.KEYBOARD,
          onKeyPressed: cbt,
          onKeyReleased: cbf
        }));
        cc.eventManager.addListener(this.cbKeys);
      }
    }
    return this.cbKeys;
  },
  regTouch: function(on_QMRK) {
    if ( (!on_QMRK) ) {
      if (this.cbTouch) {
        cc.eventManager.removeListener(this.cbTouch);
        (
        this.cbTouch = null);
      }
    } else {
      if (( (this.cbTouch === null) )) {
        let me = this;
        (this.cbTouch = cc.EventListeneer.create({
          event: cc.EventListener.TOUCH_ONE_BY_ONE,
          swallowTouches: true,
          onTouchBegan: function() {
            return true;
          },
          onTouchMoved: function() {},
          onTouchEnded: function() {}
        }));
        cc.eventManager.addListener(this.cbTouch);
      }
    }
    return this.cbTouch;
  },
  ctor: function() {
    return (this["tMode"] = cc.EventListener.TOUCH_ONE_BY_ONE, this["mouseListener"] = null, this["mouseBtn"] = cc.EventMouse.BUTTON_LEFT, this["mouseEnabled?"] = false, this["mouseTarget?"] = false, this["mouseDown?"] = false, this["keys"] = fillArray(256, false));
  },
  isMouseEnabled_QMRK: function() {
    return this.mouseEnabled;
  },
  getIID: function() {
    return 1;
  }
});
const GMode = {
  ONE: 1,
  TWO: 2,
  NET: 3,
  NICHTS: -1
};
const GameScene = XScene.extend({
  ctor: function(cfg) {
    this._super();
    return (this["cfg"] = cfg, this["pools"] = (new Map([])), this["msgQ"] = (new Map([])), this["state"] = 0, this["level"] = 1);
  },
  getCurLevel: function() {
    return this.cfg.getLevel(this.level);
  },
  getLevelCfg: function() {
    return this.cfg.getLevelCfg(this.level);
  },
  getPool: function(p) {
    return kirbystdlibref.getProp(this.pools, p);
  },
  createPool: function(p) {
    return (kirbystdlibref.assoc_BANG(this.pools, p, new ecs.EntityPool()));
  },
  resetPools: function() {
    return K.resetMap_BANG(this.pools);
  },
  getMode: function() {
    return this.context.mode;
  },
  isOnline_QMRK: function() {
    return some_QMRK(this.context.odin);
  },
  getEnclosureRect: function() {
    return cx.visRect();
  },
  getEnclosureBox: function() {
    return cx.visBox();
  },
  play: function() {
    return (this.state = 911);
  },
  isLive_QMRK: function() {
    return (this.state > 0);
  },
  stop_BANG: function() {
    return (this.state = 0);
  },
  getLevel: function() {
    return this.level;
  },
  sendMsg: function(topic) {
    return sendMsgEx(topic, null);
  }
});
const GameLayer = XLayer.extend({
  decoPost: function() {
    if (this.engine) {
      this.engine.ignite();
    }
    return this.scheduleUpdate();
  },
  preDeco: function() {
    cx.resumeAudio(true, true);
    return this.enableListeners();
  },
  surcease: function() {
    this.disableListeners();
    cx.pauseAudio(true, true);
    return this.unscheduleUpdate();
  },
  update: function(dt) {
    return (((!cx.isTransitioning_QMRK()) && MainGameScene.isLive() && some_QMRK(this.engine)) ?
      this.engine.update(dt) :
      null);
  },
  ctor: function() {
    return (this["engine"] = null);
  }
});
const XLives = cc.Node.extend({
  reduce: function() {
    let GS__14 = Array.prototype.slice.call(arguments, 0);
    let x = GS__14[0];
    (
    x = opt_QMRK__QMRK(x, 1));
    return (function() {
      for (let ____break = false; ((!____break) && (x > 0));) {
        if ( (this.icons.size > 0) ) {
          null;
        }
        (x -= 1);
        (
        this.curLives -= 1);
      }
    }).call(this);
  },
  reset: function() {
    this.icons.forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return ____args[0].removeFromParent();
    });
    K.resetVec_BANG(this.icons);
    return (this.curLives = this.totalLives);
  },
  resurrect: function() {
    this.reset();
    return this.drawLives();
  },
  drawLives: function() {
    let v,
      x,
      y;
    return (function() {
      for (let n = 0, GS__15 = this.curLives, ____break = false; ((!____break) && (n < GS__15)); n = (n + 1)) {
        (
        v = cx.createSprite(this.frameId));
        v.setScale(this.scale);
        if (( (n === 0) )) {
          (this.lifeSize = cx.scaleSize(CC_CSIZE(v), this.scale), y = (this.refPt.y - HHZ(this.lifeSize)), x = (this.refPt.x + HWZ(this.lifeSize)));
        }
        v.setPosition(x, y);
        this.addChild(v);
        conj_BANG(this.icons, v);
        if ( (this.dir > 0) ) {
          (
          x += (1.2 * this.lifeSize.width));
        } else {
          (
          x -= (1.2 * this.lifeSize.width));
        }
      }
    }).call(this);
  },
  initLives: function(frame, lives, x, y) {
    let GS__16 = Array.prototype.slice.call(arguments, 4);
    let scale = GS__16[0];
    let d = GS__16[1];
    (this.totalLives = lives, this.frameId = frame, this.curLives = 0, this.dir = opt_QMRK__QMRK(d, 1), this.scale = opt_QMRK__QMRK(scale, 1), this.refPt = cc.p(x, y));
    this.reset();
    return this.drawLives();
  },
  ctor: function() {
    return (this["icons"] = [], this["lifeSize"] = cc.size(0, 0), this["refPt"] = cc.p(0, 0), this["frameId"] = "", this["scale"] = 1, this["dir"] = 1, this["totalLives"] = 0, this["curLives"] = 0);
  },
  isDead_QMRK: function() {
    return (this.curLives <= 0);
  },
  getLives: function() {
    return this.curLives;
  }
});
const ____macros = {
  "class": "(macro* class (name super & xs) (syntax-quote (const (unquote name) (.extend (unquote super) (object (splice-unquote xs))))))"
};
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.elmo.x2d.core",
    macros: ____macros
  },
  createSoundToggles: createSoundToggles,
  addSSheetNode: addSSheetNode,
  addSpriteFrame: addSpriteFrame,
  addItem: addItem,
  centerImage: centerImage,
  removeBatchAll: removeBatchAll,
  removeAll: removeAll,
  removeItem: removeItem,
  XScene: XScene,
  XLayer: XLayer,
  GMode: GMode,
  GameScene: GameScene,
  GameLayer: GameLayer,
  XLives: XLives
};