/*Auto generated by Kirby v1.0.0 - Wed Feb 07 2018 17:52:42 GMT-0800 (PST)
  

*/

const K = require("kirby");
const conj_BANG = K["conj_BANG"];
const kirbystdlibref = require("kirby");
const __module_namespace__ = "czlab.elmo.core.CCSX";
////////////////////////////////////////////////////////////////////////////////
//fn: [popScene] in file: CCSX.ky, line: 18
const popScene = function() {
  return cc.director.popScene();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [randomPos] in file: CCSX.ky, line: 21
const randomPos = function(node) {
  let GS__3 = visBox();
  let right = kirbystdlibref.getProp(GS__3, "right");
  let top = kirbystdlibref.getProp(GS__3, "top");
  return node.setPosition(randInt(right), randInt(top));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [mkHMenu] in file: CCSX.ky, line: 26
const mkHMenu = function(items, pad) {
  return mkMenu(items, false, pad);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [mkVMenu] in file: CCSX.ky, line: 29
const mkVMenu = function(items, pad) {
  return mkMenu(items, true, pad);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [mkMenu] in file: CCSX.ky, line: 32
//Menu-items should be same size
const mkMenu = function(items, vert_QMRK, pad) {
  let menu = cc.Menu.create();
  items.forEach(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return menu.addChild(____args[0]);
  });
  if (vert_QMRK) {
    menu.alignItemsVerticallyWithPadding(pad);
  } else {
    menu.alignItemsHorizontallyWithPadding(pad);
  }
  return menu;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [menuOneItem] in file: CCSX.ky, line: 43
const menuOneItem = function(item) {
  return (function() {
    let GS__4 = cc.Menu.create();
    GS__4.addChild(item);
    GS__4.setPosition(0, 0);
    GS__4.setAnchorPoint(_STAR_anchor_DASH_bl_STAR);
    return GS__4;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [isDesktop] in file: CCSX.ky, line: 50
const isDesktop = function() {
  return (function() {
    throw new Error("TBD");
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [splitHexColor] in file: CCSX.ky, line: 53
const splitHexColor = function(rgbstr) {
  let f = /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/;
  let s = /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/;
  let len = kirbystdlibref.count(rgbstr);
  let arr = (f.exec(rgbstr) || s.exec(rgbstr));
  return (arr ?
    (function() {
      (
      arr = Array.prototype.slice.call(arr, 1));
      return ((len === 4) ?
        arr.map(function() {
          let ____args = Array.prototype.slice.call(arguments);
          return [____args[0], ____args[0]].join("");
        }) :
        arr).map(function() {
        let ____args = Array.prototype.slice.call(arguments);
        return parseInt(["0x", ____args[0]].join(""));
      });
    }).call(this) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [colorRGB] in file: CCSX.ky, line: 65
const colorRGB = function(rgbstr) {
  return cc.hexToColor(rgbstr);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sfxMusic] in file: CCSX.ky, line: 70
const sfxMusic = function(music, repeat_QMRK) {
  return (function() {
    try {
      return cc.audioEngine.playMusic(music, repeat_QMRK);
    } catch (e) {
      return cc.warn(cc.formatStr("Failed to play music: %s", music));
    }
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sfxEffect] in file: CCSX.ky, line: 76
const sfxEffect = function(sound) {
  return (function() {
    try {
      return cc.audioEngine.playEffect(sound);
    } catch (e) {
      return cc.warn(cc.formatStr("Failed to play sound: %s", sound));
    }
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pauseAudio] in file: CCSX.ky, line: 82
const pauseAudio = function(effects_QMRK, music_QMRK) {
  if (music_QMRK) {
    cc.audioEngine.pauseMusic();
  }
  return (effects_QMRK ?
    cc.audioEngine.pauseAllEffects() :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resumeAudio] in file: CCSX.ky, line: 87
const resumeAudio = function(effects_QMRK, music_QMRK) {
  if (music_QMRK) {
    cc.audioEngine.resumeMusic();
  }
  return (effects_QMRK ?
    cc.audioEngine.resumeAllEffects() :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [stopAudio] in file: CCSX.ky, line: 92
const stopAudio = function(effects_QMRK, music_QMRK) {
  if (music_QMRK) {
    cc.audioEngine.stopMusic();
  }
  return (effects_QMRK ?
    cc.audioEngine.stopAllEffects() :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [calcOffsets] in file: CCSX.ky, line: 97
const calcOffsets = function(sz) {
  return cc.size((sz.width / _STAR_golden_DASH_ratio_STAR), (sz.height / _STAR_golden_DASH_ratio_STAR));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createSpriteBatch] in file: CCSX.ky, line: 102
const createSpriteBatch = function(image) {
  return cc.SpriteBatchNode.createWithTexture(cc.textureCache.addImage(image));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createAudioMItems] in file: CCSX.ky, line: 107
const createAudioMItems = function() {
  let GS__5 = Array.prototype.slice.call(arguments, 0);
  let onIcon = GS__5[0];
  let ovIcon = GS__5[1];
  (ovIcon = opt_QMRK__QMRK(ovIcon, "sound_off.png"), onIcon = opt_QMRK__QMRK(onIcon, "sound_on.png"));
  return [createMenuBtn(ovIcon, ovIcon), createMenuBtn(onIcon, onIcon)];
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createAudioMImages] in file: CCSX.ky, line: 114
const createAudioMImages = function() {
  let GS__6 = Array.prototype.slice.call(arguments, 0);
  let onIcon = GS__6[0];
  let ovIcon = GS__6[1];
  (ovIcon = opt_QMRK__QMRK(ovIcon, "sound_off.png"), onIcon = opt_QMRK__QMRK(onIcon, "sound_on.png"));
  return [createMenuImg(ovIcon, ovIcon), createMenuImg(onIcon, onIcon)];
};
////////////////////////////////////////////////////////////////////////////////
//fn: [calcDist] in file: CCSX.ky, line: 121
const calcDist = function(a, b) {
  return cc.pDistance(a.getPosition(), b.getPosition());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [normalize] in file: CCSX.ky, line: 126
const normalize = function(a, b) {
  return cc.pNormalize(cc.pSub(b.getPosition(), a.getPosition()));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createMenuText] in file: CCSX.ky, line: 131
const createMenuText = function(fnt, txt, color) {
  let GS__7 = Array.prototype.slice.call(arguments, 3);
  let pointSize = GS__7[0];
  let z = (some_QMRK(pointSize) ?
    createTTFLabel(fnt, pointSize, txt) :
    createBMFLabel(fnt, txt));
  z.setColor(color);
  return cc.MenuItemLabel.create(z);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createMenuBtn] in file: CCSX.ky, line: 138
const createMenuBtn = function(frame_QMRK, normal) {
  let GS__8 = Array.prototype.slice.call(arguments, 2);
  let selected = GS__8[0];
  (
  selected = opt_QMRK__QMRK(selected, normal));
  return (frame_QMRK ?
    cc.MenuItemSprite.create(createSprite(normal), createSprite(selected)) :
    cc.MenuItemImage.create(xcfg.getImage(normal), xcfg.getImage(selected)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pointInBox?] in file: CCSX.ky, line: 147
//Test if this point is inside this rectangle
const pointInBox_QMRK = function(box, x) {
  let GS__9 = Array.prototype.slice.call(arguments, 2);
  let y = GS__9[0];
  if ( (!((typeof (x) === "number"))) ) {
    (y = x.y, x = x.x);
  }
  return ((x >= box.left) && (x <= box.right) && (y >= box.bottom) && (y <= box.top));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createTextLabel] in file: CCSX.ky, line: 158
const createTextLabel = function(fnt, txt) {
  let GS__10 = Array.prototype.slice.call(arguments, 2);
  let pointSize = GS__10[0];
  return (some_QMRK(pointSize) ?
    new cc.LabelTTF(txt, fnt, pointSize) :
    new cc.LabelBMFont(txt, fnt));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sprite?] in file: CCSX.ky, line: 164
const sprite_QMRK = function(s) {
  return (s instanceof cc.Sprite);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [collide?] in file: CCSX.ky, line: 167
//Test collision of 2 sprites
const collide_QMRK = function(a, b) {
  return ((a && b) ?
    bbox(a).intersectsRect(bbox(b)) :
    false);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [setDevRes] in file: CCSX.ky, line: 173
const setDevRes = function(x, y, policy) {
  return cc.director.getOpenGLView().setDesignResolutionSize(x, y, policy);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [isTapped?] in file: CCSX.ky, line: 178
const isTapped_QMRK = function(node, tap) {
  let d = tap.distance(node.getPosition());
  let GS__11 = node.getBoundingBox();
  let width = kirbystdlibref.getProp(GS__11, "width");
  let height = kirbystdlibref.getProp(GS__11, "height");
  return ((d <= (0.8 * width)) || (d <= (0.8 * height)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [deltaX] in file: CCSX.ky, line: 185
const deltaX = function(a, b) {
  return (a.getPositionX() - b.getPositionX());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [deltaY] in file: CCSX.ky, line: 188
const deltaY = function(a, b) {
  return (a.getPositionY() - b.getPositionY());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [isPortrait?] in file: CCSX.ky, line: 191
const isPortrait_QMRK = function() {
  let s = screenSize();
  return (s.height > s.width);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [readPlist] in file: CCSX.ky, line: 194
const readPlist = function(url) {
  return cc.plistParser.parse(jsb.fileUtils.getStringFromFile(url));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [readJson] in file: CCSX.ky, line: 198
const readJson = function(url) {
  return JSON.parse(jsb.fileUtils.getStringFromFile(url));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [outOfBound?] in file: CCSX.ky, line: 206
const outOfBound_QMRK = function(a, B) {
  return ((a instanceof Box4) && (B instanceof Box4) && ((a.left > B.right) || (a.top < B.bottom) || (a.right < B.left) || (a.bottom > B.top)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [scaleSize] in file: CCSX.ky, line: 215
const scaleSize = function(z, scale) {
  return cc.size((z.width * scale), (z.height * scale));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [undoTimer] in file: CCSX.ky, line: 218
const undoTimer = function(tm) {
  return (tm ?
    tm.release() :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createTime] in file: CCSX.ky, line: 221
//Create a timer action
const createTime = function(par, millis) {
  let t = cc.DelayTime.create((millis / 1000));
  t.retain();
  par.runAction(t);
  return t;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [timerDone?] in file: CCSX.ky, line: 230
const timerDone_QMRK = function(t) {
  return (t ?
    t.isDone() :
    undefined);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createAnimation] in file: CCSX.ky, line: 233
const createAnimation = function(dpu, loops, restore_QMRK) {
  return (function() {
    let GS__12 = cc.Animation.create();
    GS__12.setDelayPerUnit(dpu);
    GS__12.setLoops(loops);
    GS__12.setRestoreOriginalFrame(restore_QMRK);
    return GS__12;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createSpriteFromPath] in file: CCSX.ky, line: 240
//Create a sprite.
const createSpriteFromPath = function(path, name) {
  return new cc.Sprite([path, "/", name].join(""));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createSprite] in file: CCSX.ky, line: 244
//Create a sprite.
const createSprite = function(name) {
  return new cc.Sprite(name);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [bbox4] in file: CCSX.ky, line: 247
const bbox4 = function(n) {
  let r = n.getBoundingBox();
  return Box4((r.y + r.height), (r.x + r.width), r.y, r.x);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [runEx] in file: CCSX.ky, line: 252
const runEx = function(s) {
  let GS__13 = Array.prototype.slice.call(arguments, 1);
  let delay = GS__13[0];
  return run(s, delay);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [run] in file: CCSX.ky, line: 255
const run = function(s) {
  let GS__14 = Array.prototype.slice.call(arguments, 1);
  let delay = GS__14[0];
  return (((typeof (delay) === "number")) ?
    cc.director.replaceScene(cc.TransitionCrossFade.create(delay, s)) :
    cc.director.replaceScene());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [pushScene] in file: CCSX.ky, line: 262
const pushScene = function(s) {
  let GS__15 = Array.prototype.slice.call(arguments, 1);
  let delay = GS__15[0];
  return cc.director.pushScene(cc.TransitionCrossFade.create(delay, s));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [isTransitioning?] in file: CCSX.ky, line: 267
const isTransitioning_QMRK = function() {
  return some_QMRK(cc.director.getRunningScene());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [calcSize] in file: CCSX.ky, line: 270
//Find size of this sprite
const calcSize = function(frame) {
  let b = createSprite(frame).getBoundingBox();
  return cc.size(b.width, b.height);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [halfHW] in file: CCSX.ky, line: 277
//Calculate halves of width and height of this sprite
const halfHW = function(s) {
  let b = s.getBoundingBox();
  return cc.size((0.5 * b.width), (0.5 * b.height));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [bbox] in file: CCSX.ky, line: 284
//Rectangle from this sprite
const bbox = function(s) {
  return s.getBoundingBox();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getHeight] in file: CCSX.ky, line: 288
const getHeight = function(s) {
  return s.getBoundingBox().height;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getWidth] in file: CCSX.ky, line: 291
const getWidth = function(s) {
  return s.getBoundingBox().width;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getContentHeight] in file: CCSX.ky, line: 294
const getContentHeight = function(s) {
  return s.getContentSize().height;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getContentWidth] in file: CCSX.ky, line: 297
const getContentWidth = function(s) {
  return s.getContentSize().width;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [get-XXX] in file: CCSX.ky, line: 300
const get_DASH_XXX = function(s, px, bound) {
  let w = s.getBoundingBox().width;
  let a = s.getAnchorPoint().x;
  return (px + (w * (bound - a)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [get-YYY] in file: CCSX.ky, line: 306
const get_DASH_YYY = function(s, py, bound) {
  let h = s.getBoundingBox().height;
  let a = s.getAnchorPoint().y;
  return (py + (h * (bound - a)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getLeft] in file: CCSX.ky, line: 312
const getLeft = function(s) {
  return get_DASH_XXX(s, s.getPosition().x, _STAR_anchor_DASH_l_STAR.x);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getRight] in file: CCSX.ky, line: 316
const getRight = function(s) {
  return get_DASH_XXX(s, s.getPosition().x, _STAR_anchor_DASH_r_STAR.x);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getBottom] in file: CCSX.ky, line: 320
const getBottom = function(s) {
  return get_DASH_YYY(s, s.getPosition().y, _STAR_anchor_DASH_b_STAR.y);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getTop] in file: CCSX.ky, line: 324
const getTop = function(s) {
  return get_DASH_YYY(s, s.getPosition().y, _STAR_anchor_DASH_t_STAR.y);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [centerX] in file: CCSX.ky, line: 328
//x pos of the center of the visible screen
const centerX = function() {
  return centerPoint().x;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [centerY] in file: CCSX.ky, line: 332
//y pos of the center of the visible screen.
const centerY = function() {
  return centerPoint().y;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [centerPoint] in file: CCSX.ky, line: 336
//Get the center of the visible screen
const centerPoint = function() {
  let pt = visOrigin();
  let sz = visSize();
  return cc.p((pt.x + HWZ(sz.width)), (pt.y + HHZ(sz.height)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [screenHeight] in file: CCSX.ky, line: 343
//Get the screen height
const screenHeight = function() {
  return screenSize().height;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [screenWidth] in file: CCSX.ky, line: 347
//Get the screen width
const screenWidth = function() {
  return screenSize().width;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [visOrigin] in file: CCSX.ky, line: 351
const visOrigin = function() {
  return cc.director.getOpenGLView().getVisibleOrigin();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [visSize] in file: CCSX.ky, line: 354
const visSize = function() {
  return cc.director.getOpenGLView().getVisibleSize();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [visBox] in file: CCSX.ky, line: 357
//Get the visible screen box
const visBox = function() {
  let pt = visOrigin();
  let sz = visSize();
  return new Box4((pt.y + sz.height), (pt.x + sz.width), pt.y, pt.x);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [screenSize] in file: CCSX.ky, line: 363
//Get the actual window/frame size.
const screenSize = function() {
  return cc.director.getOpenGLView().getFrameSize();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [vboxMID] in file: CCSX.ky, line: 368
//Get the center of this box.
const vboxMID = function(box) {
  return cc.p((box.left + (0.5 * (box.right - box.left))), (box.bottom + (0.5 * (box.top - box.bottom))));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [traceEnclosure] in file: CCSX.ky, line: 374
//Test if this box is hitting boundaries
//rect.x & y are center positioned
//If hit, the new position and velocities
//are returned
const traceEnclosure = function(dt, bbox, rect, vel) {
  let sz = (rect.top - rect.bottom);
  let sw = (rect.right - rect.left);
  let y = (rect.bottom + (sz * 0.5) + (dt * vel.y));
  let x = (rect.left + (sw * 0.5) + (dt * vel.x));
  let vx = vel.x;
  let vy = vel.y;
  let hit_QMRK = false;
  if ( ((y + sz) > bbox.top) ) {
    (y = (bbox.top - sz), vy = (-1 * vy), hit_QMRK = true);
  } else {
    if ( ((y - sz) < bbox.bottom) ) {
      (y = (bbox.bottom + sz), vy = (-1 * vy), hit_QMRK = true);
    } else {
      null;
    }
  }
  if ( ((x + sw) > bbox.right) ) {
    (x = (bbox.right - sw), vx = (-1 * vx), hit_QMRK = true);
  } else {
    if ( ((x - sw) < bbox.left) ) {
      (x = (bbox.left + sw), vx = (-1 * vx), hit_QMRK = true);
    } else {
      null;
    }
  }
  return (new Map([["hit?", hit_QMRK], ["pos", cc.p(x, y)], ["vel", cc.p(vx, vy)]]));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [isIntersect?] in file: CCSX.ky, line: 412
const isIntersect_QMRK = function(a1, a2) {
  return (!((a1.left > a2.right) || (a2.left > a1.right) || (a1.top < a2.bottom) || (a2.top < a1.bottom)));
};
const _STAR_scac_STAR = function() {
  let xs = Array.prototype.slice.call(arguments, 0);
  let that = cc.spriteFrameCache;
  return that.getSpriteFrameByName.apply(that, xs);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getSpriteFrame] in file: CCSX.ky, line: 424
//Get the sprite from the frame cache
//using its id (e.g. #ship)
const getSpriteFrame = function(frameid) {
  let GS__16 = Array.prototype.slice.call(arguments, 1);
  let rect = GS__16[0];
  let f = _STAR_scac_STAR(frameid);
  if (f) {
    if (rect) {
      f.setRect(rect);
    }
  }
  return f;
};
const _STAR_anchor_DASH_c_STAR = cc.p(0.5, 0.5);
const _STAR_anchor_DASH_t_STAR = cc.p(0.5, 1);
const _STAR_anchor_DASH_tr_STAR = cc.p(1, 1);
const _STAR_anchor_DASH_r_STAR = cc.p(1, 0.5);
const _STAR_anchor_DASH_br_STAR = cc.p(1, 0);
const _STAR_anchor_DASH_b_STAR = cc.p(0.5, 0);
const _STAR_anchor_DASH_bl_STAR = cc.p(0, 0);
const _STAR_anchor_DASH_l_STAR = cc.p(0, 0.5);
const _STAR_anchor_DASH_tl_STAR = cc.p(0, 1);
const _STAR_csize_STAR = function(s) {
  let b = s.getBoundingBox();
  return cc.size(b.width, b.height);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resolveElastic] in file: CCSX.ky, line: 448
//not used for now.
const resolveElastic = function(obj1, vel1, obj2, vel2) {
  let pos2 = obj2.getPosition();
  let pos1 = obj1.getPosition();
  let sz2 = _STAR_csize_STAR(obj2);
  let sz1 = _STAR_csize_STAR(obj1);
  let hh1 = HHZ(sz1);
  let hw1 = HWZ(sz1);
  let x = pos1.x;
  let y = pos1.y;
  let bx2 = bbox4(obj2);
  let bx1 = bbox4(obj1);
  if ( ((bx1.left < bx2.right) && (bx2.right < bx1.right)) ) {
    (kirbystdlibref.assoc_BANG(vel2, "x", (-1 * fabs(vel2.x))));
    (kirbystdlibref.assoc_BANG(vel1, "x", fabs(vel1.x)));
    (
    x = (getRight(obj2) + hw1));
  } else {
    if ( ((bx1.right > bx2.left) && (bx1.left < bx2.left)) ) {
      (kirbystdlibref.assoc_BANG(vel1, "x", (-1 * fabs(vel1.x))));
      (kirbystdlibref.assoc_BANG(vel2, "x", fabs(vel2.x)));
      (
      x = (getLeft(obj2) - hw1));
    } else {
      if ( ((bx1.bottom < bx2.top) && (bx1.top > bx2.top)) ) {
        (kirbystdlibref.assoc_BANG(vel2, "y", (-1 * fabs(vel2.y))));
        (kirbystdlibref.assoc_BANG(vel1, "y", fabs(vel1.y)));
        (
        y = (getTop(obj2) + hh1));
      } else {
        if ( ((bx1.top > bx2.bottom) && (bx2.bottom > bx1.bottom)) ) {
          (kirbystdlibref.assoc_BANG(vel1, "y", (-1 * fabs(vel1.y))));
          (kirbystdlibref.assoc_BANG(vel2, "y", fabs(vel2.y)));
          (
          y = (getBottom(obj2) - hh1));
        } else {
          null;
        }
      }
    }
  }
  return null;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [clamp3] in file: CCSX.ky, line: 491
const clamp3 = function(loc, sz, world) {
  let hh = HHZ(sz);
  let hw = HWZ(sz);
  let x = loc.x;
  let y = loc.y;
  if ( ((loc.x + hw) > world.right) ) {
    (
    x = (world.right - hw));
  }
  if ( ((loc.x - hw) < world.left) ) {
    (
    x = (world.left + hw));
  }
  if ( ((loc.y - hh) < world.bottom) ) {
    (
    y = (world.bottom + hh));
  }
  if ( ((loc.y + hh) > world.top) ) {
    (
    y = (world.top - hh));
  }
  return cc.p(x, y);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [clamp2] in file: CCSX.ky, line: 507
const clamp2 = function(cur, bx) {
  return cc.pClamp(cur, cc.p(bx.left, bx.bottom), cc.p(bx.right, bx.top));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [randInt] in file: CCSX.ky, line: 513
const randInt = function(upper) {
  return Math.floor((upper * cc.ramdom0To1()));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [randFloat] in file: CCSX.ky, line: 517
const randFloat = function(upper) {
  return (upper * cc.ramdom0To1());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [randSign] in file: CCSX.ky, line: 521
const randSign = function() {
  return ((cc.ramdom0To1() > 0.5) ?
    1 :
    -1);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [rand] in file: CCSX.ky, line: 525
const rand = function() {
  return cc.ramdom0To1();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [degToRad] in file: CCSX.ky, line: 528
const degToRad = function(deg) {
  return (deg * (Math.PI / 180));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [timeInMillis] in file: CCSX.ky, line: 532
const timeInMillis = function() {
  return new Date().getTime();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [calcXY] in file: CCSX.ky, line: 535
//quadrants =  4 | 1
//--------
//3 | 2
const calcXY = function(angle, hypot) {
  let theta,
    q,
    x,
    y;
  if ( ((angle >= 0) && (angle <= 90)) ) {
    (theta = degToRad((90 - angle)), x = cos(theta), y = sin(theta), q = 1);
  } else {
    if ( ((angle >= 90) && (angle <= 180)) ) {
      (theta = degToRad((angle - 90)), x = cos(theta), y = (-1 * sin(theta)), q = 2);
    } else {
      if ( ((angle >= 180) && (angle <= 270)) ) {
        (theta = degToRad((270 - angle)), x = (-1 * cos(theta)), y = (-1 * sin(theta)), q = 3);
      } else {
        if ( ((angle >= 270) && (angle <= 360)) ) {
          (theta = degToRad((angle - 270)), x = (-1 * cos(theta)), y = sin(theta), q = 4);
        } else {
          null;
        }
      }
    }
  }
  return cc.p((x * hypot), (y * hypot));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [throttle] in file: CCSX.ky, line: 570
const throttle = function(func, wait) {
  let previous = 0;
  return function() {
    let now = timeInMillis();
    if (( (previous === 0) )) {
      (
      previous = now);
    }
    let remaining = (wait - (now - previous));
    return (((remaining <= 0) || (remaining > wait)) ?
      (function() {
        (
        previous = now);
        return func();
      }).call(this) :
      null);
  };
};
////////////////////////////////////////////////////////////////////////////////
//fn: [testCollideEntity] in file: CCSX.ky, line: 583
const testCollideEntity = function(p1, ent) {
  return (kirbystdlibref.getProp(ent, "status") ?
    (function() {
      return p1.foreach(function(e) {
        return testCollideEntities(e, ent);
      });
    }).call(this) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [testCollidePools] in file: CCSX.ky, line: 590
const testCollidePools = function(p1, p2) {
  return p1.foreach(function(e1) {
    return p2.foreach(function(e2) {
      return testCollideEntities(e1, e2);
    });
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [testCollideEntities] in file: CCSX.ky, line: 598
const testCollideEntities = function(e1, e2) {
  let s2 = e2.get("pixie");
  let s1 = e1.get("pixie");
  return ((kirbystdlibref.getProp(e2, "status") && kirbystdlibref.getProp(e1, "status") && collide(s2, s1)) ?
    (function() {
      kirbystdlibref.getProp(e2, "health").hurt();
      return kirbystdlibref.getProp(e1, "health").hurt();
    }).call(this) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [hibernate] in file: CCSX.ky, line: 608
const hibernate = function(ent) {
  let s = kirbystdlibref.getProp(ent, "pixie");
  if (s) {
    s.deflate();
  }
  return ent.drop_BANG();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resurrect] in file: CCSX.ky, line: 614
const resurrect = function(ent, x, y) {
  let h = kirbystdlibref.getProp(ent, "health");
  let s = kirbystdlibref.getProp(ent, "pixie");
  if (s) {
    s.inflate(x, y);
  }
  if (h) {
    h.reset();
  }
  return ent.take_BANG();
};
////////////////////////////////////////////////////////////////////////////////
//fn: [kumakaze] in file: CCSX.ky, line: 622
const kumakaze = function(ent) {
  let h = kirbystdlibref.getProp(ent, "health");
  return (h ?
    (kirbystdlibref.assoc_BANG(h, "curHP", 0)) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [resolveEntities] in file: CCSX.ky, line: 628
const resolveEntities = function(pool) {
  return pool.foreach(function(e) {
    return (kirbystdlibref.getProp(e, "status") ?
      (function() {
        let ht = kirbystdlibref.getProp(e, "health");
        return ((ht && (!kirbystdlibref.getProp(ht, "alive?"))) ?
          hibernate(e) :
          null);
      }).call(this) :
      null);
  });
};
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.elmo.core.CCSX",
    macros: {}
  },
  popScene: popScene,
  randomPos: randomPos,
  mkHMenu: mkHMenu,
  mkVMenu: mkVMenu,
  menuOneItem: menuOneItem,
  isDesktop: isDesktop,
  colorRGB: colorRGB,
  sfxMusic: sfxMusic,
  sfxEffect: sfxEffect,
  pauseAudio: pauseAudio,
  resumeAudio: resumeAudio,
  stopAudio: stopAudio,
  calcOffsets: calcOffsets,
  createSpriteBatch: createSpriteBatch,
  createAudioMItems: createAudioMItems,
  createAudioMImages: createAudioMImages,
  calcDist: calcDist,
  normalize: normalize,
  createMenuText: createMenuText,
  createMenuBtn: createMenuBtn,
  pointInBox_QMRK: pointInBox_QMRK,
  createTextLabel: createTextLabel,
  sprite_QMRK: sprite_QMRK,
  collide_QMRK: collide_QMRK,
  setDevRes: setDevRes,
  isTapped_QMRK: isTapped_QMRK,
  deltaX: deltaX,
  deltaY: deltaY,
  isPortrait_QMRK: isPortrait_QMRK,
  readPlist: readPlist,
  readJson: readJson,
  outOfBound_QMRK: outOfBound_QMRK,
  scaleSize: scaleSize,
  undoTimer: undoTimer,
  createTime: createTime,
  timerDone_QMRK: timerDone_QMRK,
  createAnimation: createAnimation,
  createSpriteFromPath: createSpriteFromPath,
  createSprite: createSprite,
  bbox4: bbox4,
  runEx: runEx,
  run: run,
  pushScene: pushScene,
  isTransitioning_QMRK: isTransitioning_QMRK,
  calcSize: calcSize,
  halfHW: halfHW,
  bbox: bbox,
  getHeight: getHeight,
  getWidth: getWidth,
  getContentHeight: getContentHeight,
  getContentWidth: getContentWidth,
  get_DASH_XXX: get_DASH_XXX,
  get_DASH_YYY: get_DASH_YYY,
  getLeft: getLeft,
  getRight: getRight,
  getBottom: getBottom,
  getTop: getTop,
  centerX: centerX,
  centerY: centerY,
  centerPoint: centerPoint,
  screenHeight: screenHeight,
  screenWidth: screenWidth,
  visOrigin: visOrigin,
  visSize: visSize,
  visBox: visBox,
  screenSize: screenSize,
  vboxMID: vboxMID,
  traceEnclosure: traceEnclosure,
  isIntersect_QMRK: isIntersect_QMRK,
  _STAR_scac_STAR: _STAR_scac_STAR,
  getSpriteFrame: getSpriteFrame,
  _STAR_anchor_DASH_c_STAR: _STAR_anchor_DASH_c_STAR,
  _STAR_anchor_DASH_t_STAR: _STAR_anchor_DASH_t_STAR,
  _STAR_anchor_DASH_tr_STAR: _STAR_anchor_DASH_tr_STAR,
  _STAR_anchor_DASH_r_STAR: _STAR_anchor_DASH_r_STAR,
  _STAR_anchor_DASH_br_STAR: _STAR_anchor_DASH_br_STAR,
  _STAR_anchor_DASH_b_STAR: _STAR_anchor_DASH_b_STAR,
  _STAR_anchor_DASH_bl_STAR: _STAR_anchor_DASH_bl_STAR,
  _STAR_anchor_DASH_l_STAR: _STAR_anchor_DASH_l_STAR,
  _STAR_anchor_DASH_tl_STAR: _STAR_anchor_DASH_tl_STAR,
  _STAR_csize_STAR: _STAR_csize_STAR,
  resolveElastic: resolveElastic,
  clamp3: clamp3,
  clamp2: clamp2,
  randInt: randInt,
  randFloat: randFloat,
  randSign: randSign,
  rand: rand,
  degToRad: degToRad,
  timeInMillis: timeInMillis,
  calcXY: calcXY,
  throttle: throttle,
  testCollideEntity: testCollideEntity,
  testCollidePools: testCollidePools,
  testCollideEntities: testCollideEntities,
  hibernate: hibernate,
  resurrect: resurrect,
  kumakaze: kumakaze,
  resolveEntities: resolveEntities
};